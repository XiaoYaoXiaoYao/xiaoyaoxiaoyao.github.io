{"meta":{"title":"XiaoYao_博客","subtitle":"","description":"","author":"XiaoYao","url":"https://xiaoyaoxiaoyao.github.io","root":"/"},"pages":[{"title":"categories","date":"2020-05-19T15:06:49.000Z","updated":"2020-05-19T15:07:23.071Z","comments":true,"path":"categories/index.html","permalink":"https://xiaoyaoxiaoyao.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-05-19T15:03:45.000Z","updated":"2020-05-19T15:05:32.845Z","comments":true,"path":"tags/index.html","permalink":"https://xiaoyaoxiaoyao.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Ajax笔记","slug":"ajax中的data中的数据传递时的记录","date":"2020-07-24T08:36:58.000Z","updated":"2020-07-24T08:36:35.497Z","comments":true,"path":"2020/07/24/ajax中的data中的数据传递时的记录/","link":"","permalink":"https://xiaoyaoxiaoyao.github.io/2020/07/24/ajax%E4%B8%AD%E7%9A%84data%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%E6%97%B6%E7%9A%84%E8%AE%B0%E5%BD%95/","excerpt":"","text":"ajax发送json数据时为什么需要设置contentType: “application/json” 1. ajax发送json数据时设置contentType: “application/json”和不设置时到底有什么区别？contentType: “application/json”，首先明确一点，这也是一种文本类型（和text/json一样），表示json格式的字符串，如果ajax中设置为该类型，则发送的json对象必须要使用JSON.stringify进行序列化成字符串才能和设定的这个类型匹配。同时，对应的后端如果使用了Spring，接收时需要使用@RequestBody来注解，这样才能将发送过来的json字符串解析绑定到对应的 pojo 属性上。另外，需注意一点，json字符串在书写时名称部分需要加上“”双引号，以免一些json解析器无法识别。 如ajax 请求时不设置任何contentType，默认将使用contentType: “application/json”application/x-www-form-urlencoded，这种格式的特点就是，name/value 成为一组，每组之间用 &amp; 联接，而 name与value 则是使用 = 连接。如： www.baidu.com/query?user=username&amp;pass=password 这是get请求, 而 post 请求则是使用请求体，参数不在 url 中，在请求体中的参数表现形式也是: user=username&amp;pass=password的形式。使用这种contentType时，对于简单的json对象类型，如：{“a”:1,”b”:2,”c”:3} 这种，将也会被转成user=username&amp;pass=password 这种形式发送到服务端。而服务端接收时就按照正常从from表单中接收参数那样接收即可，不需设置@RequestBody之类的注解。但对于复杂的json 结构数据，这种方式处理起来就相对要困难，服务端解析时也难以解析，所以，就有了application/json 这种类型，这是一种数据格式的申明，明确告诉服务端是什么格式的数据，服务端只需要根据这种格式的特点来解析数据即可。 总结：1).ajax 如果发送的是json字符串，服务端接收时必须要使用@RequestBody注解。始终记住，json字符串，”application/json”，@RequestBody 这三者之间是一一对应的，要有都有，要没有都没有。2).如果发送的是json对象，contentType不能设置为”application/json”，需使用默认的类型（application/x-www-form-urlencoded，为什么呢？这种类型最后还是会把json对象类型的参数转为user=username&amp;pass=password这种形式后再发送，需要明白一点：这种转换时只能识别json对象类型，不能识别json字符串类型）。 2.application/x-www-form-urlencoded 和 application/json 两种类型的数据在后端如何接收并解析？application/x-www-form-urlencoded 这种类型的参数提交方式有get和post两种，这两种方式的区别是前者把编码后的user=username&amp;pass=password这种形式的参数放在url上进行提交，后者是放在请求报文的请求体部分进行发送，只是发送数据时数据放的位置不一样。服务端收到 user=username&amp;pass=password 这种形式的参数后，原生的Servlet使用request.getParameter(“user”)的这种形式即可获取参数，spring mvc 中 框架可自动根据参数名进行匹配，即表单元素的name属性和接收参数的名称一样时即可自动匹配，如果不一样，还可以使用@RequestParam的方式匹配。 application/json 字符串数据原生的Servlet中可以使用request.getParameterMap()来获取，但需注意，这种只能获取Get方式传入的数据。post传入的需要使用输入流的方式来读取。在spring mvc中通过@RequestBody来解析并绑定json字符串参数到方法入参。 补充知识（摘录,博文来源：**https://blog.csdn.net/ff906317011/article/details/78552426****）：** @RequestBody 注解详解 作用： 1) 该注解用于读取Request请求的body部分数据，使用系统默认配置的HttpMessageConverter进行解析，然后把相应的数据绑定到要返回的对象上；2) 再把HttpMessageConverter返回的对象数据绑定到 controller中方法的参数上。 使用时机： A) GET、POST方式提时， 根据request header Content-Type的值来判断: 1）application/x-www-form-urlencoded， 可选（即非必须，因为这种情况的数据@RequestParam, @ModelAttribute也可以处理，当然@RequestBody也能处理）；2）multipart/form-data, 不能处理（即使用@RequestBody不能处理这种格式的数据）；3）其他格式， 必须（其他格式包括application/json, application/xml等。这些格式的数据，必须使用@RequestBody来处理）； B) PUT方式提交时， 根据request header Content-Type的值来判断: application/x-www-form-urlencoded， 必须；multipart/form-data, 不能处理；其他格式， 必须. 1前端使用post传递数据,传入的obj是对象类型,没有写contextType,那么默认就是application/json”application/x-www-form-urlencoded,因为是post方式传递,所以参数会放在请求体中的form-data中,所以后端直接使用String roleId 等等来接受参数 1虽然能接受到参数,但是复杂的json对象就不能接收到了,String name (Joe),所以需要在ajax中添加contentType:&quot;application/json&quot;,同时需要将obj对象转换为json类型的字符串,而后端接收需要使用@RequestBody User user 来接收","categories":[{"name":"Ajax","slug":"Ajax","permalink":"https://xiaoyaoxiaoyao.github.io/categories/Ajax/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://xiaoyaoxiaoyao.github.io/tags/Java/"}]},{"title":"面试真题","slug":"面试真题","date":"2019-12-15T07:49:36.000Z","updated":"2020-05-19T15:27:51.445Z","comments":true,"path":"2019/12/15/面试真题/","link":"","permalink":"https://xiaoyaoxiaoyao.github.io/2019/12/15/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/","excerpt":"","text":"JavaSE1.final ,finally,finalize的区别 2.equals和”==” 的区别?3.简述Spring事务的隔离级别4.写出不低于三种单例模式的实现方式5.多线程有几种实现方法?同步有几种实现方法?6.Http请求的get和post方式的区别?7.说一说Servlet的生命周期?8.MVC单词全拼及作用?9.JQuery中的$()是什么含义?10.JDBC中Class.forName的作用?为什么要用?11.为什么要使用JDBC?可以直接通过socket和从数据库查数据吗?12.构造器Constructor是否可被override?13.面向对象的特征有哪些?14.String s =new String (“xyz”);创建了几个String 对象?两者之间有什么区别?15.如何把一段逗号分割的字符串转换成一个数组?16.数组有没有length()方法?String有没有length()方法?17.冒泡排除算法?18.描述Java中&amp;和&amp;&amp; 的区别?19.char类型 的变量中能不能存储一个中文汉字?为什么?20.使用final关键字修饰一个变量时,是引用不能变,还是引用的对象不能变?21.Integer 和int的区别?22.重载和返回值无关的理解? 重载链接 23.构造方法,非静态代码块,静态代码块的执行顺序? 24.数据库调优?25.redis,mongoDB?26.算法?","categories":[{"name":"面试题","slug":"面试题","permalink":"https://xiaoyaoxiaoyao.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://xiaoyaoxiaoyao.github.io/tags/Java/"}]},{"title":"JVM笔记","slug":"JVM笔记","date":"2019-12-07T06:57:58.000Z","updated":"2020-05-19T15:25:33.677Z","comments":true,"path":"2019/12/07/JVM笔记/","link":"","permalink":"https://xiaoyaoxiaoyao.github.io/2019/12/07/JVM%E7%AC%94%E8%AE%B0/","excerpt":"","text":"栈(Stack): 在函数中定义的一些基本类型的变量和对象的引用变量(变量名)都在函数的栈内存中分配 堆(Heap): 堆内存用来存放由new创建出来的对象和数组 常量池: 深入理解JVM内存分配和常量池","categories":[{"name":"JVM","slug":"JVM","permalink":"https://xiaoyaoxiaoyao.github.io/categories/JVM/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://xiaoyaoxiaoyao.github.io/tags/Java/"}]},{"title":"SpringBoot笔记","slug":"Spring Boot 笔记","date":"2019-12-07T06:57:58.000Z","updated":"2020-05-19T15:26:22.217Z","comments":true,"path":"2019/12/07/Spring Boot 笔记/","link":"","permalink":"https://xiaoyaoxiaoyao.github.io/2019/12/07/Spring%20Boot%20%E7%AC%94%E8%AE%B0/","excerpt":"","text":"==Spring Boot 笔记==一.Spring Boot 简介1.Spring Boot简介 简化Spring应用开发的一个框架 整个Spring技术栈的一个大整合 J2EE开发的一站式解决方案 2.环境准备 –jdk1.8：Spring Boot 推荐jdk1.7及以上；java version “1.8.0_112” –maven3.x：maven 3.3以上版本；Apache Maven 3.3.9 –IntelliJIDEA2017：IntelliJ IDEA 2017.2.2 x64、STS –SpringBoot 1.5.9.RELEASE：1.5.9； 3.Spring Boot快速入门需求: 浏览器发送hello请求,服务器接收请求并处理,响应Hello World字符串 idea生成的springboot目录结构: 步骤: 1.创建一个maven工程:2.导入spring boot相关依赖1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 3.编写一个主程序: 启动springboot应用123456789101112/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; 4、编写相关的Controller、Service12345678910@Controllerpublic class HelloWorld&#123; @RequestMapping @ResponseBody public String hello()&#123; return \"Hello World!\"; &#125; &#125; 5.浏览器进行访问1localhost:8080/hello 二.Spring Boot的优缺点1.Spring Boot 的核心功能 1.独立运行的Spring 项目Spring Boot 可以以jar包的形式独立运行，运行一个Spring Boot 项目只需要通过 java -jar xx.jar 来运行。 2.内嵌Servlet 容器Spring Boot 可以选择内嵌Tomcat、Jetty或Undertow，这样我们无须以war包形式部署项目。 3.提供starter简化Maven 配置Spring 提供了一系列的starter pom 来简化Maven 的依赖加载。 4.自动配置SpringSpring Boot 会根据在类路径中的jar包、类，为jar包里的类自动配置Bean，这样会极大地减少我们要使用的配置。Spring Boot只考虑了大多数的场景，并不是所有的场景。 5.生产的应用监控Spring Boot 提供基于http、ssh、telnet对运行时的项目进行监控。 6.无代码生成和xml配置Spring Boot不是借助代码生成来实现的，而是通过条件注解来实现的，这是spring 4.x的新特性。Spring 4.x提倡使用Java配置和注解配置组合，而Spring Boot不需要任何xml配置即可实现Spring 的所有配置。 三、Hello World探究1、POM文件父项目1234567891011121314&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;他的父项目是&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt;他来真正管理Spring Boot应用里面的所有依赖版本； Spring Boot的版本仲裁中心； 以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号） 2、启动器1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; spring-boot-starter-==web==: ​ spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件； Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器 3.主程序类,主入口类123456789101112/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; @SpringBootApplication: Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用； @SpringBootConfiguration: springboot的配置类 ​ 标注在某个类上,表示这是一个springboot的配置类 ​ @Configuration:配置类上来标注这个注解 ​ 配置类: 配置文件; 配置类也是容器中的一个组件; @Component @EnableAutoConfiguration: 开启自动配置功能 ​ 以前我们需要配置的东西,springboot帮我们自动配置; @EnableAutoConfiguration告诉springboot开启自动配置功能;这样自动配置才能生效; 点进去后的注解: 123@AutoConfigurationPackage@Import(EnableAutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; @AutoConfigurationPackage：自动配置包 ​ @Import(AutoConfigurationPackages.Registrar.class)： ​ Spring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class； ==将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；== ==Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；==以前我们需要自己配置的东西，自动配置类都帮我们； 四.配置文件1.配置文件springboot使用一个全局的配置文件,配置文件名是固定的; application.properties application.yml 配置文件的作用: 修改springboot自动配置的默认值;springboot在底层都给我们自动配置好; YAML (YAML Ain’t Markup Language) ​ YAML A Markup Language：是一个标记语言 ​ YAML isn’t Markup Language：不是一个标记语言； 标记语言： ​ 以前的配置文件；大多都使用的是 xxxx.xml文件； ​ YAML：以数据为中心，比json、xml等更适合做配置文件； ​ YAML：配置例子 12server: port: 8081 xml: 123&lt;server&gt; &lt;port&gt;8081&lt;/port&gt;&lt;/server&gt; 2.YAML语法:1.基本语法k:(空格)v：表示一对键值对（空格必须有）； 以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的 123server: port: 8081 path:/hello 属性和值也是大小写敏感； 2.值的写法字面量：普通的值（数字，字符串，布尔）k: v：字面直接来写； ​ 字符串默认不用加上单引号或者双引号； ​ “”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思 ​ name: “zhangsan \\n lisi”：输出；zhangsan 换行 lisi ​ ‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据 ​ name: ‘zhangsan \\n lisi’：输出；zhangsan \\n lisi 对象、Map（属性和值）（键值对）：k: v：在下一行来写对象的属性和值的关系；注意缩进 ​ 对象还是k: v的方式 123friends: lastName:张三 age: 20 行内写法: 1friends: &#123;lastName : 张三,age: 18&#125; 数组（List、Set）：用 - 值表示数组中的一个元素 1234pets: - cat - dog - pig 行内写法: 1pets: [cat,dog,pig] 3、配置文件值注入配置文件 12345678person: lastName: hello age: 18 boss: false birth: 1984/11/19 maps: &#123;k1: v1,k2: v2&#125; lists: [lisi,zhaoliu] dog : &#123;name: tom,age : 3&#125; javaBean： 1234567891011121314151617181920212223/** * 将配置文件中的配置的每一个属性的值,映射dao这个组件中 * @ConfigurationProperties : 告诉springboot将本类中的所有属性和配置文件中的相关的配置进行绑定; * prefix = \"person\": 配置文件中哪个下面的所有属性进行一一映射 * 只有这个组件是容器中的组件,才能使用容器提供的@ConfigurationProperties功能 */@Component@ConfigurationProperties(prefix = \"person\")public class Person &#123; private String lastName ; private Integer age ; private Boolean boss; private Date birth; private Map&lt;String ,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog;&#125; 导入配置文件处理器，以后编写配置就有提示了 123456&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 打印之后的person 1、properties配置文件在idea中默认utf-8可能会乱码调整 2、@Value获取值和@ConfigurationProperties获取值比较 @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个个指定 松散绑定（松散语法） 支持 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装 支持 不支持 配置文件yml还是properties他们都能获取到值； 如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value； 如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties； 3、配置文件注入值数据校验123456789101112131415161718192021222324@Component@ConfigurationProperties(prefix = \"person\")@Validatedpublic class Person &#123; /** * &lt;bean class=\"Person\"&gt; * &lt;property name=\"lastName\" value=\"字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;\"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 @Email //@Value(\"$&#123;person.last-name&#125;\") private String lastName; //@Value(\"#&#123;11*2&#125;\") private Integer age; //@Value(\"true\") private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 4、@PropertySource&amp;@ImportResource&amp;@Bean@PropertySource：加载指定的配置文件； 1234567891011121314151617181920212223242526272829/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = \"person\"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * @ConfigurationProperties(prefix = \"person\")默认从全局配置文件中获取值； * */@PropertySource(value = &#123;\"classpath:person.properties\"&#125;)@Component@ConfigurationProperties(prefix = \"person\")//@Validatedpublic class Person &#123; /** * &lt;bean class=\"Person\"&gt; * &lt;property name=\"lastName\" value=\"字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;\"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 // @Email //@Value(\"$&#123;person.last-name&#125;\") private String lastName; //@Value(\"#&#123;11*2&#125;\") private Integer age; //@Value(\"true\") private Boolean boss; @ImportResource：导入Spring的配置文件，让配置文件里面的内容生效； Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别； 想让Spring的配置文件生效，加载进来；@ImportResource标注在一个配置类上 12@ImportResource(locations = &#123;\"classpath:beans.xml\"&#125;)导入Spring的配置文件让其生效 不来编写Spring的配置文件 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"helloService\" class=\"com.atguigu.springboot.service.HelloService\"&gt;&lt;/bean&gt;&lt;/beans&gt; springboot推荐给容器中添加组件的方式;推荐使用全注解的方式 1.配置类@Configuration–&gt;spring配置文件 2.使用@Bean给容器中添加组件 12345678910111213141516171819202122/*** @Configuration: 指明当前类是一个配置类;就是用来取代之前的spring配置文件 (xxx.xml)**在配置文件中使用&lt;bean&gt;&lt;/bean&gt;标签来添加组件*/@Configurationpublic class SpringConfiguration &#123; //将方法的返回值添加dao容器中;容器中的这个组件默认的id就是方法名 @Bean public HelloService helloService()&#123; System.out.println(\"使用@Bean注解给容器中注入组件\"); return new HelloService(); &#125;&#125;class HelloService&#123;&#125; 5、配置文件占位符1、随机数12$&#123;random.value&#125;、$&#123;random.int&#125;、$&#123;random.long&#125;$&#123;random.int(10)&#125;、$&#123;random.int[1024,65536]&#125; 2、占位符获取之前配置的值，如果没有可以是用:指定默认值123456789person.last-name=张三$&#123;random.uuid&#125;person.age=$&#123;random.int&#125;person.birth=2017/12/15person.boss=falseperson.maps.k1=v1person.maps.k2=14person.lists=a,b,cperson.dog.name=$&#123;person.hello:hello&#125;_dogperson.dog.age=15 6、配置文件加载位置12345678910111213springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件–file:./config/–file:./–classpath:/config/–classpath:/优先级由高到底，高优先级的配置会覆盖低优先级的配置；SpringBoot会从这四个位置全部加载主配置文件；**互补配置**； 7.自动配置原理:SpringBoot启动的时候加载主配置类，开启了自动配置功能 ==@EnableAutoConfiguration==五.web开发1、简介使用SpringBoot； 1）、创建SpringBoot应用，选中我们需要的模块； 2）、SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来 3）、自己编写业务代码； 2.模板引擎JSP、Velocity、Freemarker、Thymeleaf SpringBoot推荐的Thymeleaf； 语法更简单，功能更强大； 1、引入thymeleaf；123456789101112 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; 2.1.6 &lt;/dependency&gt;切换thymeleaf版本&lt;properties&gt; &lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt; &lt;!-- 布局功能的支持程序 thymeleaf3主程序 layout2以上版本 --&gt; &lt;!-- thymeleaf2 layout1--&gt; &lt;thymeleaf-layout-dialect.version&gt;2.2.2&lt;/thymeleaf-layout-dialect.version&gt; &lt;/properties&gt; 2、Thymeleaf使用1234567891011@ConfigurationProperties(prefix = \"spring.thymeleaf\")public class ThymeleafProperties &#123; private static final Charset DEFAULT_ENCODING = Charset.forName(\"UTF-8\"); private static final MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf(\"text/html\"); public static final String DEFAULT_PREFIX = \"classpath:/templates/\"; public static final String DEFAULT_SUFFIX = \".html\"; // 只要我们把HTML页面放在classpath:/templates/，thymeleaf就能自动渲染； 使用： 1、导入thymeleaf的名称空间 1&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt; 2、使用thymeleaf语法； 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;成功！&lt;/h1&gt; &lt;!--th:text 将div里面的文本内容设置为 --&gt; &lt;div th:text=\"$&#123;hello&#125;\"&gt;这是显示欢迎信息&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3、语法规则1）、th:text；改变当前元素里面的文本内容； th：任意html属性；来替换原生属性的值 2）、表达式？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869Simple expressions:（表达式语法） Variable Expressions: $&#123;...&#125;：获取变量值；OGNL； 1）、获取对象的属性、调用方法 2）、使用内置的基本对象： #ctx : the context object. #vars: the context variables. #locale : the context locale. #request : (only in Web Contexts) the HttpServletRequest object. #response : (only in Web Contexts) the HttpServletResponse object. #session : (only in Web Contexts) the HttpSession object. #servletContext : (only in Web Contexts) the ServletContext object. $&#123;session.foo&#125; 3）、内置的一些工具对象：#execInfo : information about the template being processed.#messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #&#123;…&#125; syntax.#uris : methods for escaping parts of URLs/URIs#conversions : methods for executing the configured conversion service (if any).#dates : methods for java.util.Date objects: formatting, component extraction, etc.#calendars : analogous to #dates , but for java.util.Calendar objects.#numbers : methods for formatting numeric objects.#strings : methods for String objects: contains, startsWith, prepending/appending, etc.#objects : methods for objects in general.#bools : methods for boolean evaluation.#arrays : methods for arrays.#lists : methods for lists.#sets : methods for sets.#maps : methods for maps.#aggregates : methods for creating aggregates on arrays or collections.#ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration). Selection Variable Expressions: *&#123;...&#125;：选择表达式：和$&#123;&#125;在功能上是一样； 补充：配合 th:object=\"$&#123;session.user&#125;： &lt;div th:object=\"$&#123;session.user&#125;\"&gt; &lt;p&gt;Name: &lt;span th:text=\"*&#123;firstName&#125;\"&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text=\"*&#123;lastName&#125;\"&gt;Pepper&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text=\"*&#123;nationality&#125;\"&gt;Saturn&lt;/span&gt;.&lt;/p&gt; &lt;/div&gt; Message Expressions: #&#123;...&#125;：获取国际化内容 Link URL Expressions: @&#123;...&#125;：定义URL； @&#123;/order/process(execId=$&#123;execId&#125;,execType='FAST')&#125; Fragment Expressions: ~&#123;...&#125;：片段引用表达式 &lt;div th:insert=\"~&#123;commons :: main&#125;\"&gt;...&lt;/div&gt; Literals（字面量） Text literals: 'one text' , 'Another one!' ,… Number literals: 0 , 34 , 3.0 , 12.3 ,… Boolean literals: true , false Null literal: null Literal tokens: one , sometext , main ,…Text operations:（文本操作） String concatenation: + Literal substitutions: |The name is $&#123;name&#125;|Arithmetic operations:（数学运算） Binary operators: + , - , * , / , % Minus sign (unary operator): -Boolean operations:（布尔运算） Binary operators: and , or Boolean negation (unary operator): ! , notComparisons and equality:（比较运算） Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le ) Equality operators: == , != ( eq , ne )Conditional operators:条件运算（三元运算符） If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue)Special tokens: No-Operation: _ 3.SpringMVC自动配置1.Spring MVC auto-configurationSpring Boot 自动配置好了SpringMVC 以下是SpringBoot对SpringMVC的默认配置:==（WebMvcAutoConfiguration）== Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. 自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？）） ContentNegotiatingViewResolver：组合所有的视图解析器的； ==如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来；== Support for serving static resources, including support for WebJars (see below).静态资源文件夹路径,webjars Static index.html support. 静态首页访问 Custom Favicon support (see below). favicon.ico 自动注册了 of Converter, GenericConverter, Formatter beans. Converter：转换器； public String hello(User user)：类型转换使用Converter Formatter 格式化器； 2017.12.17===Date； 2.全面接管SpringMVC；SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己配置；所有的SpringMVC的自动配置都失效了 我们需要在配置类中添加@EnableWebMvc即可 4.拦截器进行登陆检查拦截器 12345678910111213141516171819202122232425262728293031323334/** * 登陆检查， *///注册为组件@Componentpublic class LoginHandlerInterceptor implements HandlerInterceptor &#123; //目标方法执行之前 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; Object user = request.getSession().getAttribute(\"loginUser\"); if(user == null)&#123; //未登陆，返回登陆页面 request.setAttribute(\"msg\",\"没有权限请先登陆\"); request.getRequestDispatcher(\"/index.html\").forward(request,response); return false; &#125;else&#123; //已登陆，放行请求 return true; &#125; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125;&#125; 注册拦截器 1.首先将 LoginInterceptor 注入到 WebConfigurer 中。12@Autowiredprivate LoginInterceptor loginInterceptor; 2.然后在 WebConfigurer 中的 addInterceptors 中添加拦截器，使其生效。@Override public void addInterceptors(InterceptorRegistry registry) { // addPathPatterns(&quot;/**&quot;) 表示拦截所有的请求， // excludePathPatterns(&quot;/login&quot;, &quot;/register&quot;) 表示除了登陆与注册之外，因为登陆注册不需要登陆也可以访问 registry.addInterceptor(loginInterceptor).addPathPatterns(&quot;/**&quot;).excludePathPatterns(&quot;/login&quot;, &quot;/register&quot;); super.addInterceptors(registry); //较新Spring Boot的版本中这里可以直接去掉，否则会报错 }3.addPathPatterns 用来设置拦截路径，excludePathPatterns 用来设置白名单，也是不需要触发这个拦截器的路径。 完整代码： 1234567891011121314151617181920@Configurationpublic class WebConfigurer implements WebMvcConfigurer &#123; @Autowired private LoginInterceptor loginInterceptor; // 这个方法是用来配置静态资源的，比如html，js，css，等等 @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; &#125; // 这个方法用来注册拦截器，我们自己写好的拦截器需要通过这里添加注册才能生效 @Override public void addInterceptors(InterceptorRegistry registry) &#123; // addPathPatterns(\"/**\") 表示拦截所有的请求， // excludePathPatterns(\"/login\", \"/register\") 表示除了登陆与注册之外，因为登陆注册不需要登陆也可以访问 registry.addInterceptor(loginInterceptor).addPathPatterns(\"/**\").excludePathPatterns(\"/login\", \"/register\"); &#125;&#125; 六.SpringBoot与数据访问1.JDBC123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 数据源的配置文件: 123456spring: datasource: username: root password: 123456 url: jdbc:mysql://192.168.15.22:3306/jdbc driver-class-name: com.mysql.jdbc.Driver 2.整合MyBatis12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; 步骤： ​ 1）、配置数据源相关属性（见上一节Druid） ​ 2）、给数据库建表 ​ 3）、创建JavaBean 1）、注解版( 接口类UserMapper.java和配置文件UserMapper.xml,最后在入口类中使用MapperScan批量扫描所有的Mapper接口；@MapperScan(value = “com.atguigu.springboot.mapper”) ) 接口类UserMapper.java1234567891011121314151617//指定这是一个操作数据库的mapper@Mapperpublic interface DepartmentMapper &#123; @Select(\"select * from department where id=#&#123;id&#125;\") public Department getDeptById(Integer id); @Delete(\"delete from department where id=#&#123;id&#125;\") public int deleteDeptById(Integer id); @Options(useGeneratedKeys = true,keyProperty = \"id\") @Insert(\"insert into department(departmentName) values(#&#123;departmentName&#125;)\") public int insertDept(Department department); @Update(\"update department set departmentName=#&#123;departmentName&#125; where id=#&#123;id&#125;\") public int updateDept(Department department);&#125; 配置文件UserMapper.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.jf.exam.mapper.AdminStudentMapper\"&gt; &lt;resultMap id=\"studentMapper\" type=\"studentDO\"&gt; &lt;result property=\"id\" column=\"id\"/&gt; &lt;result property=\"sno\" column=\"sno\"/&gt; &lt;result property=\"name\" column=\"name\"/&gt; &lt;result property=\"password\" column=\"password\"/&gt; &lt;result property=\"fkClass\" column=\"fk_class\"/&gt; &lt;result property=\"modified\" column=\"modified\"/&gt; &lt;result property=\"delFlag\" column=\"del_flag\"/&gt; &lt;/resultMap&gt; &lt;sql id=\"_table\"&gt; student &lt;/sql&gt; &lt;sql id=\"_fields\"&gt; id,sno,`name`,`password`,fk_class,modified,del_flag &lt;/sql&gt; &lt;sql id=\"_condition\"&gt; &lt;trim prefix=\"WHERE\" prefixOverrides=\"AND|OR\"&gt; &lt;if test=\"id!=null and ''!=id\"&gt; AND id = #&#123;id&#125; &lt;/if&gt; &lt;if test=\"sno!=null and ''!=sno\"&gt; AND sno = #&#123;sno&#125; &lt;/if&gt; &lt;if test=\"name!=null and ''!=name\"&gt; AND `name` = #&#123;name&#125; &lt;/if&gt; &lt;if test=\"password!=null and ''!=password\"&gt; AND `password` = #&#123;password&#125; &lt;/if&gt; &lt;if test=\"fkClass!=null\"&gt; AND fk_class = #&#123;fkClass&#125; &lt;/if&gt; &lt;if test=\"modified!=null\"&gt; AND modified = #&#123;modified&#125; &lt;/if&gt; &lt;if test=\"delFlag!=null and ''!=delFlag\"&gt; AND del_flag = #&#123;delFlag&#125; &lt;/if&gt; &lt;/trim&gt; &lt;/sql&gt; &lt;sql id=\"_primaryKey_condition\"&gt; WHERE id = #&#123;id&#125; &lt;/sql&gt; &lt;sql id=\"_order\"&gt; &lt;if test=\"sortByParams!= null and sortByParams.size()&gt;0\" &gt; ORDER BY &lt;foreach collection=\"sortByParams.keys\" index=\"index\" item=\"sortByParamKey\" separator=\",\"&gt; &lt;![CDATA[$&#123;sortByParamKey&#125; $&#123;sortByParams[sortByParamKey]&#125;]]&gt; &lt;/foreach&gt; &lt;/if&gt; &lt;/sql&gt; &lt;insert id=\"add\" parameterType=\"studentVO\" keyProperty=\"id\"&gt; INSERT INTO &lt;include refid=\"_table\"/&gt; &lt;trim prefix=\"(\" suffix=\")\" suffixOverrides=\",\"&gt; &lt;if test=\"id!=null and ''!=id\"&gt; id, &lt;/if&gt; &lt;if test=\"sno!=null and ''!=sno\"&gt; sno, &lt;/if&gt; &lt;if test=\"name!=null and ''!=name\"&gt; `name`, &lt;/if&gt; &lt;if test=\"password!=null and ''!=password\"&gt; `password`, &lt;/if&gt; &lt;if test=\"fkClass!=null\"&gt; fk_class, &lt;/if&gt; &lt;if test=\"modified!=null\"&gt; modified, &lt;/if&gt; &lt;if test=\"delFlag!=null and ''!=delFlag\"&gt; del_flag, &lt;/if&gt; &lt;/trim&gt; &lt;trim prefix=\"values (\" suffix=\")\" suffixOverrides=\",\"&gt; &lt;if test=\"id!=null and ''!=id\"&gt; #&#123;id&#125;, &lt;/if&gt; &lt;if test=\"sno!=null and ''!=sno\"&gt; #&#123;sno&#125;, &lt;/if&gt; &lt;if test=\"name!=null and ''!=name\"&gt; #&#123;name&#125;, &lt;/if&gt; &lt;if test=\"password!=null and ''!=password\"&gt; #&#123;password&#125;, &lt;/if&gt; &lt;if test=\"fkClass!=null\"&gt; #&#123;fkClass&#125;, &lt;/if&gt; &lt;if test=\"modified!=null\"&gt; #&#123;modified&#125;, &lt;/if&gt; &lt;if test=\"delFlag!=null and ''!=delFlag\"&gt; #&#123;delFlag&#125;, &lt;/if&gt; &lt;/trim&gt; &lt;/insert&gt; &lt;update id=\"updateById\" parameterType=\"studentVO\"&gt; UPDATE &lt;include refid=\"_table\"/&gt; &lt;set&gt; &lt;if test=\"sno!=null and ''!=sno\"&gt; sno = #&#123;sno&#125;, &lt;/if&gt; &lt;if test=\"name!=null and ''!=name\"&gt; `name` = #&#123;name&#125;, &lt;/if&gt; &lt;if test=\"password!=null and ''!=password\"&gt; `password` = #&#123;password&#125;, &lt;/if&gt; &lt;if test=\"fkClass!=null\"&gt; fk_class = #&#123;fkClass&#125;, &lt;/if&gt; &lt;if test=\"modified!=null\"&gt; modified = #&#123;modified&#125;, &lt;/if&gt; &lt;if test=\"delFlag!=null and ''!=delFlag\"&gt; del_flag = #&#123;delFlag&#125;, &lt;/if&gt; &lt;/set&gt; &lt;include refid=\"_primaryKey_condition\"/&gt; &lt;/update&gt; &lt;select id=\"findById\" resultMap=\"studentMapper\" parameterType=\"String\"&gt; SELECT &lt;include refid=\"_fields\"/&gt; FROM &lt;include refid=\"_table\"/&gt; &lt;include refid=\"_primaryKey_condition\"/&gt; &lt;/select&gt; &lt;select id=\"list\" resultMap=\"studentMapper\" parameterType=\"studentVO\"&gt; SELECT &lt;include refid=\"_fields\"/&gt; FROM &lt;include refid=\"_table\"/&gt; &lt;include refid=\"_condition\"/&gt; &lt;include refid=\"_order\"/&gt; &lt;/select&gt; &lt;select id=\"listPage\" resultMap=\"studentMapper\" parameterType=\"studentVO\"&gt; SELECT &lt;include refid=\"_fields\"/&gt; FROM &lt;include refid=\"_table\"/&gt; &lt;include refid=\"_condition\"/&gt; &lt;include refid=\"_order\"/&gt; &lt;if test=\"startRecord != null and pageSize != null and pageSize &gt;0\"&gt; limit #&#123;startRecord&#125;,#&#123;pageSize&#125; &lt;/if&gt; &lt;if test=\"!(startRecord != null and pageSize != null and pageSize &gt;0)\"&gt; limit 0,15 &lt;/if&gt; &lt;/select&gt; &lt;select id=\"count\" resultType=\"java.lang.Integer\" parameterType=\"studentVO\"&gt; SELECT COUNT(*) FROM &lt;include refid=\"_table\"/&gt; &lt;include refid=\"_condition\"/&gt; &lt;/select&gt; &lt;delete id=\"deleteById\" parameterType=\"String\"&gt; DELETE FROM &lt;include refid=\"_table\"/&gt; &lt;include refid=\"_primaryKey_condition\"/&gt; &lt;/delete&gt; &lt;select id=\"listStudentAssociation\" resultMap=\"listStudentAssociationResultMap\" parameterType=\"com.jf.exam.pojo.vo.StudentVO\"&gt; SELECT s.id sid, s.sno sno, s.`name` sname, c.id cid, c.cno cno, g.id gid, g.`name` gname, m.id mid, m.`name` mname FROM student s LEFT JOIN class c ON s.fk_class = c.id LEFT JOIN grade g ON g.id = c.fk_grade LEFT JOIN major m ON m.id = c.fk_major &lt;where&gt; &lt;if test=\"name!=null and ''!=name\"&gt; s.`name`= #&#123;name&#125; &lt;/if&gt; &lt;/where&gt; &lt;if test=\"startRecord != null and pageSize != null and pageSize &gt;0\"&gt; limit #&#123;startRecord&#125;,#&#123;pageSize&#125; &lt;/if&gt; &lt;if test=\"!(startRecord != null and pageSize != null and pageSize &gt;0)\"&gt; limit 0,15 &lt;/if&gt; &lt;/select&gt; &lt;resultMap id=\"listStudentAssociationResultMap\" type=\"com.jf.exam.pojo.vo.StudentListVO\"&gt; &lt;id column=\"sid\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"sno\" property=\"sno\"&gt;&lt;/result&gt; &lt;result column=\"sname\" property=\"name\"&gt;&lt;/result&gt; &lt;association property=\"gradeDO\" javaType=\"com.jf.exam.pojo.data.GradeDO\"&gt; &lt;id column=\"gid\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"gname\" property=\"name\"&gt;&lt;/result&gt; &lt;/association&gt; &lt;association property=\"classDO\" javaType=\"com.jf.exam.pojo.data.ClassDO\"&gt; &lt;id column=\"cid\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"cno\" property=\"cno\"&gt;&lt;/result&gt; &lt;/association&gt; &lt;association property=\"majorDO\" javaType=\"com.jf.exam.pojo.data.MajorDO\"&gt; &lt;id column=\"mid\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"mname\" property=\"name\"&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt;&lt;/mapper&gt; 扫描所有的Mapper接口123456789使用MapperScan批量扫描所有的Mapper接口；@MapperScan(value = \"com.atguigu.springboot.mapper\")@SpringBootApplicationpublic class SpringBoot06DataMybatisApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot06DataMybatisApplication.class, args); &#125;&#125;","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://xiaoyaoxiaoyao.github.io/categories/SpringBoot/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://xiaoyaoxiaoyao.github.io/tags/Java/"}]},{"title":"Java面试题","slug":"Java面试题","date":"2019-12-07T02:06:32.000Z","updated":"2020-05-19T15:25:00.808Z","comments":true,"path":"2019/12/07/Java面试题/","link":"","permalink":"https://xiaoyaoxiaoyao.github.io/2019/12/07/Java%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"1.Java基础1.1简单讲一下java的跨平台的原理1由于各个操作系统(windows,linux等)支持的指令集,不是完全一致的.就会让我们的程序在不同的操作系统上要执行不同程序代码.Java开发了适用于不同操作系统及位数的java虚拟机来屏蔽各个系统之间的差异,提供统一的接口.对于java开发者而言,只需在不同的操作系统上安装对应的不同java虚拟机,这时你的java程序只要遵循java规范,就可以在所有的操作系统上面运行java程序了. 总结 1java通过不同的系统,不同的版本,不同位数的java虚拟机(jvm),来屏蔽不同系统的指令集差异而对外提供统一的接口(java Api),对于我们普通的java开发者而言,只需要按照接口开发即可.如果系统需要部署到不同的环境是,只需要在系统上面按照对应版本的虚拟机即可. 1.2讲一下java中的int数据占据几个字节java中的基本数据类型?八种 1.3面向对象的特征有哪些方面?四大基本特征:封装 继承 多态 抽象 封装:面向对象的封装性,即将对象封装成一个高度自治和相对封闭的个体,对象状态(属性) 由这个对象自己的行为(方法)来读取和改变. 继承:在定义和实现一个类的时候,可以在一个已经存在的类的基础上来进行,把这个已经存在的类所定义的内容作为自己的内容,并可以加入若干新的内容,或者修改原来的方法使之更适合特殊的需要,这就是继承.遗产继承 多态:指的是程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定,而是在程序运行期间才会确定,即一个引用变量 到底会指向哪个类的实例对象,该引用变量发出的方法调用到底是哪个类中实现的方法,必须在由程序运行期间才能决定. Object obj =new xxx(); UserDao userDao =new UserDaoImpl(); 靠的是父类或者接口定义的引用变量可以指向子类或具体实现类的实例对象,而程序调用的方法在运行期才能动态绑定,就是引用变量所指向的具体实例对象的方法,也就是内存里正在运行的那个对象的方法,而不是引用变量的类型中定义的方法. 1.4有了基本数据类型,为什么还需要包装类型?基本数据类型,java中提供了八种基本的数据类型 包装类型:每一个基本的数据类型都会一一对应一个包装类型 boolean –&gt;Boolean int –&gt; Integer 装箱和拆箱: 装箱: 把基本数据类型转换成对应的包装类型 Integer.valueOf(1) Integer i =1; 自动装箱,实际上在编译时会调用Integer.valueOf方法来装箱 int j=i;//自动拆箱 int j = i=intValue();//手动拆箱 java是一个面向对象(OOP)的语言,而基本的数据类型,不具备面向对象的特性. 而包装类型是可以为null的 null : Integer–&gt;null ​ int –&gt;0 用Integer 和int分别表示一个类的id 1.5”==”和equals方法的区别== : 用来判断两个变量之间的值是否相等.变量就可以分为基本数据类型变量和引用类型 如果是基本数据类型的变量直接比较值 而引用类型要比较对应的引用的内存的首地址. equals()：用来比较方法两个对象的内容是否相等。注意：equals 方法不能用于基本数据类型的变量，如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址。 equals 方法 Object类(超类)中的equals方法 String类中对父类的equals方法进行了重写 从上面可以看出: 没有重写的equals方法只是调用了一下==,本质是一样的 String的equals方法比较的是值,==是比较的变量的值是否相同(基本数据类型: 值比较; 引用数据类型:引用的对象的内存地址的比较) 1.6讲一下String 和String Builder 的区别(final)?StringBuilder和StringBuffer的区别?1.6.1内容是否可变12在java中提供了三个类String,StringBuffer,StringBuilder 来表示和操作字符串.字符串就是多个字符的集合.首先要知道String类进过了final修饰,所以String类型是内容不可变的字符串,String底层使用了一个不可变的字符数组 (final char[]) String str =new String(“bbb”); 而StringBuilder ,StringBuffer,是内容可以改变的字符串.StringBuilder,StringBuffer底层使用的是可变的字符数组(没有使用final修饰) 1.6.2拼接字符串String进行拼接String c=”a”+”b”; StringBuilder sb=new StringBuilder(); sb.append(“a”).append(“c”); 拼接字符串不能使用String进行拼接,要使用StringBuilder或者StringBuffer 1.6.3线程安全StringBuilder是线程不安全的,效率高;而StringBuffer是线程安全的,同时代价就是效率较低 1.7讲一下java中的集合?java中的集合分为value,key-value(Collection,Map)两种 存储值又分为 List和Set List是有序的,可以重复的 Set是无序的,不可以重复的.根据equals和hashcode判断,也就是如果一个对象要存储在Set中,必须重写equals和hashcode方法 存储key-value的为map 1.8ArrayList 和LinkedList 的区别?List常用的ArrayList和LinkedList .区别和使用场景? ArrayList底层使用的是数组.LinkedList使用的是链表 数组查询具有索引查询特定的元素比较快,而插入和删除和修改比较慢(数组在内存中是一块连续的内存,如果插入或删除是需要移动内存). 链表不要求内存是连续的,在当前元素中存放下一个或者上一个元素的地址.查询时需要从头部开始,一个一个的找.所以查询的效率低.插入时不需要移动内存,只需要改变引用指向即可.所以插入或者删除的效率高. ArrayList使用在查询比较多,但是插入和删除比较少的情况,而LinkedList使用在查询比较少而插入和删除比较多的情况 1.9将一下HashMap和HashTable的区别?相同点: HashMap和 HashTable都可以用来存储key-value的数据 区别: HashMap是可以把null作为可以或者value的,而hashTable是不可以的 HashMap是线程不安全的,效率较高.而hashTable是线程安全的,效率较低 如果想使用线程安全的同时效率高的? ConcurrentHashMap(concurrent 并行的) 1.10实现一个拷贝文件的工具类使用字节流还是字符流?我们拷贝的文件不确定是只包含字符流，有可以能有字节流(图片、声音、图像等)，为考虑到通用性，要使用字节流。 2.Java面试题先自我介绍在公司中做什么说说你对SpringMVC的了解 就是一个能够==接收前端的请求==,通过==前端控制器DispatcherServlet进行分发==,给==相应的Controller去处理相应的请求==,同时==将response响应给前端==的一个web框架. 1Spring MVC是一个基于Java的实现了MVC设计模式的请求驱动类型的轻量级Web框架，通过把Model，View，Controller分离，将web层进行职责解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。 说说你对Spring的了解123451.spring的工作原理2.spring的核心技术3.spring的优缺点 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849501.spring的工作原理spring 是按照设计模式精心打造的，它实现了工厂模式的工厂类，这个类名为BeanFactory（接口），在程序中通常使用它的子类ApplicationContext(也是接口)。spring的核心是IOC(反转控制)容器，( @Resource private AdminService adminService;) IOC也是一种编程思想，用于实现模块之间的解耦，在Spring中它的作用是对对象的创建，维护和销毁等生命周期的控制。IOC:把对象的创建、初始化、销毁交给spring来管理，而不是由开发者控制，实现控制反转。spring是一个大的工厂类，spring的特点就是基于配置，在其配置文件中通过&lt;bean&gt;元素来创建实例对象。根据业务逻辑来看，对象经常不是独立的，一个对象的创建往往涉及另一个对象的创建，当然这个对象也要由IOC容器负责，负责的方式就是依赖注入DI,通过反射机制实现。有三种注入方式：（1）接口注入（2）构造器注入（3）Setter方法注入。2.spring的核心技术spring的核心技术有：IOC,AOPjava 的 高级特性：反射机制，代理AOP:面向切面编程，系统中有很多各不相干的类的方法，在这众多方法中加入某种系统功能的代码，如加入日志，权限判断等，AOP可以实现横切关注点（如日志，安全，缓存和事务管理）与他们所影响的对象之间的解耦。实现AOP 功能采用的是代理技术，调用代理类，代理类与目标类具有相同的方法声明。AOP 在spring中主要表现在两个方面：提供声明式的事务管理 、spring支持用户自定义切面。spring AOP的使用在另外一位同学的博客中可以看到，我不喜欢造轮子就直接给大家贴一个路径吧https://www.cnblogs.com/flowwind/p/4782606.htmlAOP主要包括通知（Advice）切点（PointCut）连接点（JoinPoint）3.spring 的优缺点Spring 的核心概念是IOC和AOP,这两个核心服务的对象算是bean(POJO),定位是一个轻量级的框架，但是随着他的发展变得很庞大，我们称它为spring 全家桶。它具备以下优点：spring中避免了关键字new造成的耦合问题。spring本身就是一个工厂，不需要再编写工厂类了。spring不需要进行明确的引用关系的传递，直接通过配置完成所有框架几乎都可以在spring中整合在一起使用。spring编程=factory设计模式+proxy设计模式当然，它的缺点也是不少的：spring基于大量的xml 配置文件，使得我们花了大量的时间放在配置上，拖慢了开发的进度，springboot 问世后，提倡代码优于配置解决了这个问题。spring 的内容太庞大，随便打断点查看的时候会出现十几二十层代码，阅览性不强，在实际开发的过程中spring的角色更像是胶水一样，充当整合各种技术的角色，同时作为bean的容器。 说说你对Mybatis的了解，还用过其它ORM框架吗？1ORM（Object-Relationship-Mapping）：是对象关系映射的意思，它是一种思想，是指将数据库中的每一行数据用对象的形式表现出来。 12MyBatis概念MyBatis是一个实现了JPA规范的用来连接数据库并对其进行增删改查操作的开源框架 （就和传统的JDBC一样，就是个连接数据库的东西），其实，它底层就是一个JDBC封装的组件。MyBatis的前身是Ibatis，Ibatis创建与2002年最初为Apache下面的一个开源项目，2010迁移到google code下面并改名为MyBatis。 链接 Redis 和 MongoDB 的区别，在哪里使用过此框架。12345678910nosql和关系型数据库的区别：优点：1）成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用Oracle那样花费大量成本购买使用，相比关系型数据库价格便宜2）查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库3）存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而关系型数据库则只支持基础类型4）扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难缺点：1）不提供关系型数据库对事务的处理 12345就Redis和MongoDB来说，大家一般称之为Redis缓存、MongoDB数据库。这也是有道有理有根据的，Redis主要把数据存储在内存中，其“缓存”的性质远大于其“数据存储“的性质，其中数据的增删改查也只是像变量操作一样简单；MongoDB却是一个“存储数据”的系统，增删改查可以添加很多条件，就像SQL数据库一样灵活，这一点在面试的时候很受用。 项目中遇到的问题，用到了哪些JavaEE知识点。Java基础说一说对多态的理解？面试常客。对Java的封装、继承、 多态需要进行相关的整理。 123封装就是把对象的属性和操作（或服务）结合为一个独立的整体，并尽可能隐藏对象的内部实现细节。 使用private修饰符，表示最小的访问权限。 对成员变量的访问，统一提供setXXX，getXXX方法。 1继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。当然，如果在父类中拥有私有属性(private修饰)，则子类是不能被继承的。 123456继承：就是子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接访问父类中的非私有的属性和行为好处:1. 提高代码的复用性。2. 类与类之间产生了关系，是多态的前提。 12345678多态： 是指同一行为，具有多个不同表现形式。前提【重点】 1. 继承或者实现【二选一】2. 方法的重写【意义体现：不重写，无意义】3. 父类引用指向子类对象【格式体现】编译看左边,运行看右边 说一说SSM框架？对我们公司的了解？jvm什么时候触发gcsychronized和Lock?12345678910111213总结来说，Lock和synchronized有以下几点不同： 1）Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现； 2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁； 3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断； 4）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。 5）Lock可以提高多个线程进行读操作的效率。 在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。 反射什么是反射1反射简单来说，就是动态加载对象，并对对象进行剖析。在Java中的反射机制是指在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法; 123456789反射的应用场景反射最大的应用就是框架Spring ioc框架spring的ioc/di也是反射…JDBC的classForName()也是反射…… 虚拟机数据库海量数据mongodb 三大范式第一范式表中的每一个字段都是不可分割的列 第二范式在第一范式的基础上,其他属性完全依赖于主键 第三范式在第二范式的基础上,其他属性之间要消除依赖传递 譬如说: A依赖于B，B依赖于C，就可以说A依赖C 学号–&gt;学生名字 123这张表中有如下决定关系： 学号–&gt;姓名，性别，系号–&gt;决定系名，宿舍号–&gt;决定宿舍电话，也有 学号–&gt;系名，学号–&gt;宿舍电话。在这样一张表中则存在着传递依赖。也就是系名依赖系号，系号依赖学号，那么间接的系名依赖学号，宿舍号、宿舍电话和学号之间也有同样的关系。这样设计表的同样会带来数据冗余，操作异常等问题。那么我们同样可以用关系分解的分解的方法来消除传递依赖，将这张表分成三张表： 索引数据库索引1一个索引是存储的表中一个特定列的值数据结构（最常见的是B-Tree）。索引是在表的列上创建。所以，要记住的关键点是索引包含一个表中列的值，并且这些值存储在一个数据结构中。请记住记住这一点：索引是一种数据结构 索引的缺点① 创建索引和维护索引需要时间成本，这个成本随着数据量的增加而加大 ② 创建索引和维护索引需要空间成本，每一条索引都要占据数据库的物理存储空间，数据量越大，占用空间也越大（数据表占据的是数据库的数据空间） ③ 会降低表的增删改的效率，因为每次增删改索引需要进行动态维护，导致时间变长 用复合主键还是主键查询？1复合主键：数据库表的主键由两个及以上的字段组成。 这个主键的确定是要根据该主键能否唯一标识一行数据,来确定的 譬如: 学号和选科编号–&gt;确定了该课程的成绩 数据库的常用约束1.非空约束 not null 2.唯一约束 unique 3.主键约束 primary key 4.外键约束 foreign key 数据库常用函数count(*),max(num),min(num) count(1) 和 count(*)的区别count(1)表示的是查询表中的第一个字段,count(*)表示的是查询表中的一行中的所有字段 count(*)（是针对全表）将返回表格中所有存在的行的总数包括值为null的行； count(列名)（是针对某一列）将返回表格中某一列除去null以外的所有行的总数 当某字段名下边的数据有null值的时候，不计入这个count(1)中，*则全部列入count中 多表查询连接查询1.交叉连接查询(有错误数据, 基本不用) select * from 表A , 表B ; (笛卡尔积) 得到的是两个表的乘积 2.外连接查询: 在交叉连接的基础上 ,外连接只能取得其中一方存在的数据，外连接又分为左连接和右连接两种情况 左外连接:​ SELECT 列名1 FROM 表1 LEFT OUTER JOIN 表2 ON 表1.外键=表2.主键 WhERE 条件语句; ​ select * from 表A left [ outer ] join 表B on 条件.​ 以左边表为主, 左边有数据, 右边没有使用null代替.​ 左边没有的数据 , 右边也不能出现. 右外连接:​ SELECT 列名1 FROM 表1 RIGHT OUTER JOIN 表2 ON 表1.外键=表2.主键 WhERE 条件语句; ​ select * from 表A right [ outer ] join 表B on 条件;​ 以右边表为主 . 3.内连接查询: 在交叉连接的基础上 , 内连接就是表间的主键与外键相连，只取得键值一致的，可以获取双方表中的数据连接方式. 隐式内连接: select * rom 表A , 表B where A.外键 = B . 主键..显示外连接: ​ SELECT 列名1,列名2… FROM 表1 INNER JOIN 表2 ON 表1.外键=表2.主键 WhERE 条件语句; select * from 表A [inner] join 表B on A.外键 = B.主键​ on后面可以继续使用where条件查询. 左链接查询:见上右链接查询:见上联合查询 union 联合 合并：将多条查询语句的结果合并成一个结果 union和union all的区别是，union会自动压缩多个结果集合中的重复结果，而union all则将所有的结果全部显示出来，不管是不是重复 表操作删除表数据delete from table where id =’1’ 增删改查: 增: insert into table (字段名,字段名) values (?,?) 删: delete from table where id =’1’ 改: update table set name =’小明’ 查: select * from table 清空表后id是否重置否 分页查询语句(偏移量)select * from table limit 0,5 order by id asc 根据id升序查询表中的从索引为0的记录开始查询,查询五条数据 Shiro在项目中分为登录认证,权限认证 登录认证的流程: 1.注册securityManager 安全管理中心 2.Security.login() 当前的主体(用户)提交登陆认证 3.SecurityManager.login() 安全管理中心执行认证 4.authenticator 认证器执行认证 5.realm : 根据身份获取验证信息 JWT 注解SpringMVC注解123@Controller在SpringMVC 中，控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示。在SpringMVC 中提供了一个非常简便的定义Controller 的方法，你无需继承特定的类或实现特定的接口，只需使用@Controller 标记一个类是Controller ，然后使用@RequestMapping 等一些注解用以定义请求URL 请求和Controller 方法之间的映射，这样的Controller 就能被外界访问到。其标记在一个类上，使用它标记的类就是一个SpringMVC Controller 对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用@RequestMapping 注解。@Controller 只是定义了一个控制器类，而使用@RequestMapping 注解的方法才是真正处理请求的处理器。此外我们还需要将controller注册到spring里。 123@RequestMappingRequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径，作用于方法上，表明该处理器的请求地址=父路径+方法上url 123@requestParam@requestParam主要用于在SpringMVC后台控制层获取参数，类似一种是request.getParameter(&quot;name&quot;) 123@RequestBody该注解常用来处理Content-Type: 不是application/x-www-form-urlencoded编码的内容，例如application/json, application/xml等；它是通过使用HandlerAdapter 配置的HttpMessageConverters来解析post data body，然后绑定到相应的bean上的 举例AOP就是代理模式 事务管理 AOP 有什么通知前置通知 后置通知 环绕通知 异常通知 最终通知 Maven命令行使用1Maven是一种构建工具（打包项目）、依赖管理工具（资源依赖管理工具：主要用于集成资源）、项目信息聚合工具 jQuery 获取id1var id = $(找到这个div).attr('id'); Java集合Java 基础 List 和 Set1list和set都是单列集合collection的子接口;list中的方法可以允许重复的对象,set方法不允许重复的对象;list是有序的(存储和读取的顺序一致),set是无序的,list允许存储多个null,set只允许存储一个null;list中有关于索引的方法 Java集合排序 ArrayList 遍历 Java集合排序 实现Comparable接口和Comparator接口 ArrayList 遍历 1234567891011121314151617181920212223ArrayList arrayList = new ArrayList();arrayList.add(\"123\");arrayList.add(\"123\");arrayList.add(\"123\");arrayList.add(\"123\");arrayList.add(\"123\");//1.foreach 增强for 数组和集合的遍历for (Object o : arrayList) &#123; System.out.println(o);&#125;System.out.println(\"=================================\");//2.迭代器遍历Iterator iterator = arrayList.iterator();while (iterator.hasNext()) &#123; System.out.println(iterator.next());&#125;System.out.println(\"=================================\");//3.for循环遍历for (int i = 0; i &lt; arrayList.size(); i++) &#123; System.out.println(arrayList.get(i));&#125; 删除集合中的元素remove() ArrayList 去重通过将list集合放入set集合中,利用set集合的元素不能重复的性质 (无序) 1234567891011ArrayList arrayList = new ArrayList(); arrayList.add(\"123\"); arrayList.add(\"123\"); arrayList.add(\"123\"); arrayList.add(\"123\"); arrayList.add(\"123\"); arrayList.add(\"321\"); Set&lt;String&gt; set = new HashSet&lt;&gt;(arrayList); for (String s : set) &#123; System.out.println(s); &#125; Java hashcode 和 equals 区别 equals源码 123456789101112131415161718192021public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false;&#125; hashcode源码 1public native int hashCode(); 为什么重写equals时必须重写hashCode方法? 123hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。equals它的作用也是判断两个对象是否相等，如果对象重写了equals()方法，比较两个对象的内容是否相等；如果没有重写，比较两个对象的地址是否相同，价于“==”。同样的，equals()定义在JDK的Object.java中，这就意味着Java中的任何类都包含有equals()函数。 HashMap 是不是有序的无序的 有没有有序的Map实现类TreeMap 和 LinkedHashmap TreeMap默认是key升序，LinkedHashmap默认是数据插入顺序 hash是无序的,tree和linkedHash是有序的 TreeMap 和 LinkedHashmap如何保证有顺序的TreeMap是基于比较器Comparator来实现有序的。 LinkedHashMap是基于链表来实现数据插入有序的。 哪个有序的实现比较好？看使用场景，如果需要对Map中存储的对象进行比较，那么使用TreeMap，如果只是要求数据插入有顺序，使用LinkedHashMap 有没有更好的实现方式？HahsMap是线程安全的吗？HashMap是多线程的,不安全的,速度快; hashTable是单线程的,是安全的,速度慢 在并发下使用哪个Map类哈希表的实现数组和链表/红黑树的数据结构 哈希碰撞所谓哈希（hash），就是将不同的输入映射成独一无二的、固定长度的值（又称”哈希值”）。它是最常见的软件运算之一。 如果不同的输入得到了同一个哈希值，就发生了”哈希碰撞”（collision）。 http://www.ruanyifeng.com/blog/2018/09/hash-collision-and-birthday-attack.html 异常Java中的常见异常数组越界异常,空指针异常,类型转换异常,堆内存溢出 项目中处理异常在springboot通过定义全局异常处理器,对异常进行全局处理 多线程实现线程的方式？ 1.继承Thread类 2.实现Runnable接口 实现多线程方式的区别？继承和实现 单继承,多实现 如果想实现多个线程一起等待某个事件发生后执行sleep() 多线程 实现生产者 / 消费者模式线程安全问题SpringMVC是线程安全的吗？是安全的,Springmvc默认是单例模式 如何处理线程安全问题？同步代码块,同步方法,加锁 IO NIO当我们学习了Java NIO和IO后，我们很快就会思考一个问题： 什么时候应该使用IO，什么时候我应该使用NIO 在下文中我会尝试用例子阐述java NIO 和IO的区别，以及它们对你的设计会有什么影响 Java NIO和IO的主要区别 IO NIO 面向Stream 面向Buffer 阻塞IO 非阻塞IO 无 选择器 1、面向流与面向缓冲 ​ Java IO和NIO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。 Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。 2、阻塞与非阻塞IO ​ Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。 框架如何理解分布式？123456789狭义的分布是指，指多台PC在地理位置上分布在不同的地方。1.分布式系统 分布式系统：多个能独立运行的计算机（称为结点）组成。各个结点利用计算机网络进行信息传递，从而实现共同的“目标或者任务”。2.分布式程序：运行在分布式系统上的计算机程序。3.分布式计算：利用分布式系统来解决计算问题。在分布式计算里，一个问题被细化成多个任务，每个任务可以被一个或者多个计算机来完成 如何理解 ： 专业的事情 交给专业的人去做 尽量降低 耦合度（就是说 每个模块 是不受影响的 ） 一个模块你只做一件小事情 如何理解微服务？微服务化的核心就是将传统的一站式应用,根据业务拆分成一个一个的服务,彻底地去耦合, ​ 每一个微服务提供单个业务功能的服务,一个服务做一件事, ​ 从技术角度看就是一种小而独立的处理过程,类似进程概念,能够自行单独启动或销毁 ​ 拥有自己独立的数据库 SpringBoot用法我平常在项目中是通过idea来创建springboot项目的,首先选择所需要的依赖,然后在配置Mybatis中的数据库的数据源信息,最后通过入口函数启动springboot项目 常用注解@Repository用于标注数据访问组件， @Service用于标注业务层组件， @Component用于泛指组件， @ComponentScan用于组件扫描 @Configuration：注解在类上，表示这是一个IOC容器，相当于spring的配置文件，java配置的方式。 IOC容器的配置类一般与 @Bean 注解配合使用，用 @Configuration 注解类等价与 XML 中配置 beans，用@Bean 注解方法等价于 XML 中配置 bean @Bean： 注解在方法上，声明当前方法返回一个Bean @SpringBootApplication：@SpringBootApplication=@ComponentScan+@Configuration+@EnableAutoConfiguration：约定优于配置 MyBatis(ORM)对象关系如何配置扫描（POJO、Mapper）@Configuration配置类使用@MapperScan或者@MapperScans注解 1@MapperScan(\"cn.xiaoyao.springbootcrud.mapper\") 取值方式，以及取值的区别#{ }和${ }: 123456789101112131.#将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。如：order by #user_id#，如果传入的值是111,那么解析成sql时的值为order by &quot;111&quot;, 如果传入的值是id，则解析成的sql为order by &quot;id&quot;.2.$将传入的数据直接显示生成在sql中。如：orderby将传入的数据直接显示生成在sql中。如：orderbyuser_id$，如果传入的值是111,那么解析成sql时的值为order by user_id, 如果传入的值是id，则解析成的sql为order by id.3.#方式能够很大程度防止sql注入。4.$方式无法防止Sql注入。5.$方式一般用于传入数据库对象，例如传入表名. 6.一般能用#的就别用$.MyBatis排序时使用order by 动态参数时需要注意，用$而不是# 一对一映射一对一关联表中的查询1需求:查询订单信息关联查询用户信息 Sql语句:123456查询语句： 先确定主查询表：订单信息表 再确定关联查询表：用户信息 通过orders关联查询用户使用user_id一个外键，只能关联查询出一条用户记录就可以使用内连接SELECT orders.*,user.username,user.sex FROM orders,USER WHERE orders.user_id = user.id 使用resultType实现 创建PO类: 一对一查询映射的POJO 创建pojo包括 订单信息和用户信息，resultType才可以完成映射。创建OrderCustom作为自定义pojo(订单扩展对象,用于订单和用户的查询结果映射)，继承sql查询列多的po类。 12345public class OrderCustom extends Orders&#123; private String username;//补充用户信息 private String sex; private String address;&#125; Mapper.xml 123&lt;select id=\"findOrderUserList\" resultType=\"orderCustom\"&gt; SELECT orders.*,user.username,user.sex FROM orders,USER WHERE orders.user_id = user.id&lt;/select&gt; Mapper.java 123public interface OrderMapperCustom&#123; public List&lt;OrderCustom&gt; findOrderUserList() throws Exception;&#125; 使用resultMap实现123resultMap提供一对一关联查询的映射和一对多关联查询映射，一对一映射思路：将关联查询的信息映射到pojo中，如下：在Orders类中创建一个User属性，将关联查询的信息映射到User属性中 一对一中的主表中的POJO类:查询订单关联查询用户信息 12345678910111213141516package cn.xiaoyao.mybatis.model;import java.util.List;public class Orders &#123; private long id; private long userId; private String number; private java.sql.Timestamp createtime; private String note; //用户信息(一对一) private User user;&#125; mapper.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!--查询订单关联查询用户信息--&gt; &lt;!--通过resultMap的方法--&gt; &lt;select id=\"findOrdersUserResultMap\" resultMap=\"OrdersUserResultMap\"&gt; SELECT o.*, u.username, u.sex, u.address FROM orders o, USER u WHERE o.user_id = u.id; &lt;/select&gt; &lt;resultMap id=\"OrdersUserResultMap\" type=\"cn.xiaoyao.mybatis.model.Orders\"&gt; &lt;!--配置映射的订单信息--&gt; &lt;!-- 其中的id:指定查询列中的唯一标识,订单信息中的唯一标识 column:订单信息中的列 property:订单信息的唯一的标识列 所映射到Orders哪个属性中 --&gt; &lt;id column=\"id\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"user_id\" property=\"userId\"&gt;&lt;/result&gt; &lt;result column=\"number\" property=\"number\"&gt;&lt;/result&gt; &lt;result column=\"createtime\" property=\"createtime\"&gt;&lt;/result&gt; &lt;result column=\"note\" property=\"note\"&gt;&lt;/result&gt; &lt;!--配置订单关联查询用户的信息--&gt; &lt;!--一个订单对应一个用户--&gt; &lt;!-- association:用于映射关联查询单个对象的信息 property:要将关联查询的用户信息映射到Orders中的哪个属性 --&gt; &lt;association property=\"user\" javaType=\"cn.xiaoyao.mybatis.model.User\"&gt; &lt;!--id:关联查询用户的唯一标识--&gt; &lt;id column=\"user_id\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"username\" property=\"username\"&gt;&lt;/result&gt; &lt;result column=\"sex\" property=\"sex\"&gt;&lt;/result&gt; &lt;result column=\"address\" property=\"address\"&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt; mapper.java 12//查询订单关联查询用户信息(通过resultMap的方法) List&lt;Orders&gt; findOrdersUserResultMap(); 小结:1234resultType：要自定义pojo 保证sql查询列和pojo的属性对应，这种方法相对较简单，所以应用广泛。resultMap：使用association完成一对一映射需要配置一个resultMap，过程有点复杂，如果要实现延迟加载就只能用resultMap实现 ，如果为了方便对关联信息进行解析，也可以用association将关联信息映射到pojo中方便解析。 一对多映射一对多关联表中的查询1需求:要查询订单信息及订单下的订单明细信息 SQL语句: select o.*,od.id odid,od.items_id,od.items_num from orders o,orderdetail od where o.id=od.orders_id resultMap进行一对多映射思路: resultMap提供&lt;collection&gt;标签完成关联信息映射到集合对象中 一对多中的主表的POJO类查询订单表以及关联的订单明细信息 在Orders类中创建集合属性:123456789101112131415161718package cn.xiaoyao.mybatis.model;import java.util.List;public class Orders &#123; private long id; private long userId; private String number; private java.sql.Timestamp createtime; private String note; //订单明细(一对多) private List&lt;Orderdetail&gt; orderdetailList;&#125; mapper.xml 123456789101112131415161718192021222324252627&lt;!--查询订单表以及关联的订单明细信息--&gt; &lt;select id=\"ordersOrderdetail\" resultMap=\"OrdersOrderdetailMap\"&gt; select o.*,od.id odid,od.items_id,od.items_num from orders o,orderdetail od where o.id=od.orders_id &lt;/select&gt; &lt;resultMap id=\"OrdersOrderdetailMap\" type=\"cn.xiaoyao.mybatis.model.Orders\"&gt; &lt;!--配置orders订单表中的信息--&gt; &lt;id column=\"id\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"user_id\" property=\"userId\"&gt;&lt;/result&gt; &lt;result column=\"number\" property=\"number\"&gt;&lt;/result&gt; &lt;result column=\"createtime\" property=\"createtime\"&gt;&lt;/result&gt; &lt;result column=\"note\" property=\"note\"&gt;&lt;/result&gt; &lt;!-- 配置关联的ordersDetail表中的信息 ofType：指定映射到list集合属性中pojo的类型(就是一对多中的List&lt;T&gt;中的泛型T的类型) --&gt; &lt;collection property=\"orderdetailList\" ofType=\"cn.xiaoyao.mybatis.model.Orderdetail\"&gt; &lt;id column=\"odid\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"items_id\" property=\"itemsId\"&gt;&lt;/result&gt; &lt;result column=\"items_num\" property=\"itemsNum\"&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; mapper.java 12//查询订单关联查询订单明细表信息(通过resultMap的方法)List&lt;Orders&gt; ordersOrderdetail(); 多对多映射 和上面的一对多写法一样 ——&gt;只是数据库中的表的关系是多对多 还使用过什么缓存框架？Redis项目中如何使用Redis在springboot项目中导入redis的依赖,然后在springboot的配置文件中配置redis数据库的配置,然后在业务层中注入StringRedisTemplate类来进行对redis的数据读写操作 Redis 数据结构Redis支持五种数据类型：String（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。 主从备份就是redis服务器实现读写分离，提高数据库服务器的性能，通过一个master服务器，只负责写的操作，然后在master服务器下连接多个slave服务器，这些服务器只负责读的操作，而主服务器进行同步数据，master数据库中的数据同步到slave服务器中。 隔离级别事务的四大特性： 原子性： 持久性： 隔离性： 一致性： 事务的隔离级别: 读未提交（Read Uncommitted） 读已提交（Read Committed） 可重复读（Repeated Read） 串行化（Serializable） 事务的隔离级别产生的问题: 脏读 不可重复读 幻读 MongoDB在springboot项目中导入MongoDB的依赖,然后在springboot的配置文件中配置MongoDB数据库的配置,然后在业务层中注入MongoTemplate类来进行对MongoDB的数据读写操作 设计模式 spring中的三大设计模式: ​ 1.单例模式 ​ 2.工厂模式 ​ 3.代理模式 单例模式饿汉懒汉被Spring 管理的对象默认是单例还是多例？单例 工厂模式代理模式前端会不会前端前后端怎么分离的对MVVM的理解Vue的生命周期什么是双向绑定什么是路由什么是行内标签Bootstrap预定义类栅格系统Thymeleaf 和 jsp的区别Servlet的作用，和SpringMVC比较有什么区别？Session 和 Cookie如何实现非法登陆验证HTTP 协议HTTP请求方式和RESTFulPOST 传递的参数具体是在那？项目项目里面解决过最复杂的问题反射哪里使用了反射？你了解这个项目吗？短信验证码处理疯狂请求？项目中的表关系SEO优化","categories":[{"name":"面试题","slug":"面试题","permalink":"https://xiaoyaoxiaoyao.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://xiaoyaoxiaoyao.github.io/tags/Java/"}]},{"title":"SpringBoot项目的搭建流程","slug":"SpringBoot项目的搭建流程","date":"2019-12-02T14:07:32.000Z","updated":"2020-05-19T15:27:05.626Z","comments":true,"path":"2019/12/02/SpringBoot项目的搭建流程/","link":"","permalink":"https://xiaoyaoxiaoyao.github.io/2019/12/02/SpringBoot%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/","excerpt":"","text":"环境: SpringBoot 2.2.1 idea 1.搭建项目所需的依赖 ==之后再pom.xml中还要引入JDBC的实现类druid连接池的依赖== 2.配置文件1因为引入了Druid连接池,所以要进行数据库的数据源的信息的配置 123456789#配置Druid的数据源spring : datasource: name : vue_jf url : jdbc:mysql://localhost:3306/vue_jf?useSSL=false&amp;serverTimezone=UTC username: root password: root driver-class-name: com.mysql.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource url : jdbc:mysql://localhost:3306/vue_jf==?useSSL=false&amp;serverTimezone=UTC== 不能少 因为springboot中的thymeleaf,所以不用在配置静态资源的问题","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://xiaoyaoxiaoyao.github.io/categories/SpringBoot/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://xiaoyaoxiaoyao.github.io/tags/Java/"}]},{"title":"hexo博客的搭建","slug":"hexo博客的搭建-必看","date":"2019-11-26T04:59:05.000Z","updated":"2020-05-19T15:24:30.780Z","comments":true,"path":"2019/11/26/hexo博客的搭建-必看/","link":"","permalink":"https://xiaoyaoxiaoyao.github.io/2019/11/26/hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-%E5%BF%85%E7%9C%8B/","excerpt":"","text":"Hexo 博客的搭建前言,首先要搭建hexo博客,需要git(github账号),node.js==1.git== git的安装 : 按住Ctrl点我下载 安装步骤: 下载msi的文件后,双击安装,一路next,安装完成后,win+ R 输入cmd确定,在命令行里输入 命令:git --version,查看版本如下 ==2.node.js== 点我下载Node.js :windows安装包 安装步骤: 下载msi的文件后,双击安装,一路next,安装完成后,win+ R 输入cmd确定,在命令行里输入 命令:node -v,查看版本如下 ==3.安装hexo== 首先创建一个文件夹,用来存放博客中的东西 在新建的文件夹下鼠标右键 选择git bash here打开git命令行,输入 npm install hexo -g进行全局安装hexo,安装完成之后,查看版本号确认安装hexo -v 然后进行hexo 的初始化,输入hexo init,看到如下的列表 node_modules：是依赖包 public：存放的是生成的页面 scaffolds：命令生成文章等的模板 source：用命令创建的各种文章 themes：主题 _config.yml：整个博客的配置 db.json：source解析所得到的 package.json：项目所需模块项目的配置信息 ==4.Github仓库== 创建一个repo，名称为yourname.github.io,输入的一个标点都不能错, 其中yourname是你的github账号的名称，按照这个规则创建才有用，否则永远的404页面 搭建好github环境之后,开始进行hexo博客的搭建 4.1._config.yml的修改用编辑器打开你的blog项目，修改_config.yml文件的一些配置(冒号之后都是有一个半角空格的(yaml语法格式))： 1234deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 4.2安装hexo-deployer-git插件 1npm install hexo-deployer-git --save 4.3.生成hexo静态页面 回到gitbash中，进入你的博客目录，分别执行以下命令 123hexo cleanhexo generatehexo server 5.完成效果图","categories":[{"name":"博客","slug":"博客","permalink":"https://xiaoyaoxiaoyao.github.io/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://xiaoyaoxiaoyao.github.io/tags/hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-11-25T14:25:04.405Z","updated":"2019-11-25T14:25:04.406Z","comments":true,"path":"2019/11/25/hello-world/","link":"","permalink":"https://xiaoyaoxiaoyao.github.io/2019/11/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}