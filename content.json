{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"JVM笔记","slug":"JVM笔记","date":"2019-12-07T06:57:58.000Z","updated":"2019-12-07T07:11:19.930Z","comments":true,"path":"2019/12/07/JVM笔记/","link":"","permalink":"http://yoursite.com/2019/12/07/JVM%E7%AC%94%E8%AE%B0/","excerpt":"","text":"栈(Stack): 在函数中定义的一些基本类型的变量和对象的引用变量(变量名)都在函数的栈内存中分配 堆(Heap): 堆内存用来存放由new创建出来的对象和数组 常量池: 深入理解JVM内存分配和常量池","categories":[],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]},{"title":"Java面试题","slug":"Java面试题","date":"2019-12-07T02:06:32.000Z","updated":"2019-12-07T10:56:35.279Z","comments":true,"path":"2019/12/07/Java面试题/","link":"","permalink":"http://yoursite.com/2019/12/07/Java%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"1.Java基础1.1简单讲一下java的跨平台的原理1由于各个操作系统(windows,linux等)支持的指令集,不是完全一致的.就会让我们的程序在不同的操作系统上要执行不同程序代码.Java开发了适用于不同操作系统及位数的java虚拟机来屏蔽各个系统之间的差异,提供统一的接口.对于java开发者而言,只需在不同的操作系统上安装对应的不同java虚拟机,这时你的java程序只要遵循java规范,就可以在所有的操作系统上面运行java程序了. 总结 1java通过不同的系统,不同的版本,不同位数的java虚拟机(jvm),来屏蔽不同系统的指令集差异而对外提供统一的接口(java Api),对于我们普通的java开发者而言,只需要按照接口开发即可.如果系统需要部署到不同的环境是,只需要在系统上面按照对应版本的虚拟机即可. 1.2讲一下java中的int数据占据几个字节java中的基本数据类型?八种 1.3面向对象的特征有哪些方面?四大基本特征:封装 继承 多态 抽象 封装:面向对象的封装性,即将对象封装成一个高度自治和相对封闭的个体,对象状态(属性) 由这个对象自己的行为(方法)来读取和改变. 继承:在定义和实现一个类的时候,可以在一个已经存在的类的基础上来进行,把这个已经存在的类所定义的内容作为自己的内容,并可以加入若干新的内容,或者修改原来的方法使之更适合特殊的需要,这就是继承.遗产继承 多态:指的是程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定,而是在程序运行期间才会确定,即一个引用变量 到底会指向哪个类的实例对象,该引用变量发出的方法调用到底是哪个类中实现的方法,必须在由程序运行期间才能决定. Object obj =new xxx(); UserDao userDao =new UserDaoImpl(); 靠的是父类或者接口定义的引用变量可以指向子类或具体实现类的实例对象,而程序调用的方法在运行期才能动态绑定,就是引用变量所指向的具体实例对象的方法,也就是内存里正在运行的那个对象的方法,而不是引用变量的类型中定义的方法. 1.4有了基本数据类型,为什么还需要包装类型?基本数据类型,java中提供了八种基本的数据类型 包装类型:每一个基本的数据类型都会一一对应一个包装类型 boolean –&gt;Boolean int –&gt; Integer 装箱和拆箱: 装箱: 把基本数据类型转换成对应的包装类型 Integer.valueOf(1) Integer i =1; 自动装箱,实际上在编译时会调用Integer.valueOf方法来装箱 int j=i;//自动拆箱 int j = i=intValue();//手动拆箱 java是一个面向对象(OOP)的语言,而基本的数据类型,不具备面向对象的特性. 而包装类型是可以为null的 null : Integer–&gt;null ​ int –&gt;0 用Integer 和int分别表示一个类的id 1.5”==”和equals方法的区别== : 用来判断两个变量之间的值是否相等.变量就可以分为基本数据类型变量和引用类型 如果是基本数据类型的变量直接比较值 而引用类型要比较对应的引用的内存的首地址. equals()：用来比较方法两个对象的内容是否相等。注意：equals 方法不能用于基本数据类型的变量，如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址。 equals 方法 Object类(超类)中的equals方法 String类中对父类的equals方法进行了重写 从上面可以看出: 没有重写的equals方法只是调用了一下==,本质是一样的 String的equals方法比较的是值,==是比较的变量的值是否相同(基本数据类型: 值比较; 引用数据类型:引用的对象的内存地址的比较) 1.6讲一下String 和String Builder 的区别(final)?StringBuilder和StringBuffer的区别?1.6.1内容是否可变12在java中提供了三个类String,StringBuffer,StringBuilder 来表示和操作字符串.字符串就是多个字符的集合.首先要知道String类进过了final修饰,所以String类型是内容不可变的字符串,String底层使用了一个不可变的字符数组 (final char[]) String str =new String(“bbb”); 而StringBuilder ,StringBuffer,是内容可以改变的字符串.StringBuilder,StringBuffer底层使用的是可变的字符数组(没有使用final修饰) 1.6.2拼接字符串String进行拼接String c=”a”+”b”; StringBuilder sb=new StringBuilder(); sb.append(“a”).append(“c”); 拼接字符串不能使用String进行拼接,要使用StringBuilder或者StringBuffer 1.6.3线程安全StringBuilder是线程不安全的,效率高;而StringBuffer是线程安全的,同时代价就是效率较低 1.7讲一下java中的集合?java中的集合分为value,key-value(Collection,Map)两种 存储值又分为 List和Set List是有序的,可以重复的 Set是无序的,不可以重复的.根据equals和hashcode判断,也就是如果一个对象要存储在Set中,必须重写equals和hashcode方法 存储key-value的为map 1.8ArrayList 和LinkedList 的区别?List常用的ArrayList和LinkedList .区别和使用场景? ArrayList底层使用的是数组.LinkedList使用的是链表 数组查询具有索引查询特定的元素比较快,而插入和删除和修改比较慢(数组在内存中是一块连续的内存,如果插入或删除是需要移动内存). 链表不要求内存是连续的,在当前元素中存放下一个或者上一个元素的地址.查询时需要从头部开始,一个一个的找.所以查询的效率低.插入时不需要移动内存,只需要改变引用指向即可.所以插入或者删除的效率高. ArrayList使用在查询比较多,但是插入和删除比较少的情况,而LinkedList使用在查询比较少而插入和删除比较多的情况 1.9将一下HashMap和HashTable的区别?相同点: HashMap和 HashTable都可以用来存储key-value的数据 区别: HashMap是可以把null作为可以或者value的,而hashTable是不可以的 HashMap是线程不安全的,效率较高.而hashTable是线程安全的,效率较低 如果想使用线程安全的同时效率高的? ConcurrentHashMap(concurrent 并行的) 1.10实现一个拷贝文件的工具类使用字节流还是字符流?我们拷贝的文件不确定是只包含字符流，有可以能有字节流(图片、声音、图像等)，为考虑到通用性，要使用字节流。","categories":[],"tags":[{"name":"Java面试题","slug":"Java面试题","permalink":"http://yoursite.com/tags/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"SpringBoot项目的搭建流程","slug":"SpringBoot项目的搭建流程","date":"2019-12-02T14:07:32.000Z","updated":"2019-12-02T14:49:02.326Z","comments":true,"path":"2019/12/02/SpringBoot项目的搭建流程/","link":"","permalink":"http://yoursite.com/2019/12/02/SpringBoot%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/","excerpt":"","text":"环境: SpringBoot 2.2.1 idea 1.搭建项目所需的依赖 ==之后再pom.xml中还要引入JDBC的实现类druid连接池的依赖== 2.配置文件1因为引入了Druid连接池,所以要进行数据库的数据源的信息的配置 123456789#配置Druid的数据源spring : datasource: name : vue_jf url : jdbc:mysql://localhost:3306/vue_jf?useSSL=false&amp;serverTimezone=UTC username: root password: root driver-class-name: com.mysql.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource url : jdbc:mysql://localhost:3306/vue_jf==?useSSL=false&amp;serverTimezone=UTC== 不能少 因为springboot中的thymeleaf,所以不用在配置静态资源的问题","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"Spring Boot 笔记","slug":"Spring Boot 笔记","date":"2019-11-28T08:58:32.356Z","updated":"2019-11-28T08:57:57.035Z","comments":true,"path":"2019/11/28/Spring Boot 笔记/","link":"","permalink":"http://yoursite.com/2019/11/28/Spring%20Boot%20%E7%AC%94%E8%AE%B0/","excerpt":"","text":"==Spring Boot 笔记==一.Spring Boot 简介1.Spring Boot简介 简化Spring应用开发的一个框架 整个Spring技术栈的一个大整合 J2EE开发的一站式解决方案 2.环境准备 –jdk1.8：Spring Boot 推荐jdk1.7及以上；java version “1.8.0_112” –maven3.x：maven 3.3以上版本；Apache Maven 3.3.9 –IntelliJIDEA2017：IntelliJ IDEA 2017.2.2 x64、STS –SpringBoot 1.5.9.RELEASE：1.5.9； 3.Spring Boot快速入门需求: 浏览器发送hello请求,服务器接收请求并处理,响应Hello World字符串 idea生成的springboot目录结构: 步骤: 1.创建一个maven工程:2.导入spring boot相关依赖1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 3.编写一个主程序: 启动springboot应用123456789101112/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; 4、编写相关的Controller、Service12345678910@Controllerpublic class HelloWorld&#123; @RequestMapping @ResponseBody public String hello()&#123; return \"Hello World!\"; &#125; &#125; 5.浏览器进行访问1localhost:8080/hello 二.Spring Boot的优缺点1.Spring Boot 的核心功能 1.独立运行的Spring 项目Spring Boot 可以以jar包的形式独立运行，运行一个Spring Boot 项目只需要通过 java -jar xx.jar 来运行。 2.内嵌Servlet 容器Spring Boot 可以选择内嵌Tomcat、Jetty或Undertow，这样我们无须以war包形式部署项目。 3.提供starter简化Maven 配置Spring 提供了一系列的starter pom 来简化Maven 的依赖加载。 4.自动配置SpringSpring Boot 会根据在类路径中的jar包、类，为jar包里的类自动配置Bean，这样会极大地减少我们要使用的配置。Spring Boot只考虑了大多数的场景，并不是所有的场景。 5.生产的应用监控Spring Boot 提供基于http、ssh、telnet对运行时的项目进行监控。 6.无代码生成和xml配置Spring Boot不是借助代码生成来实现的，而是通过条件注解来实现的，这是spring 4.x的新特性。Spring 4.x提倡使用Java配置和注解配置组合，而Spring Boot不需要任何xml配置即可实现Spring 的所有配置。 三、Hello World探究1、POM文件父项目1234567891011121314&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;他的父项目是&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt;他来真正管理Spring Boot应用里面的所有依赖版本； Spring Boot的版本仲裁中心； 以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号） 2、启动器1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; spring-boot-starter-==web==: ​ spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件； Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器 3.主程序类,主入口类123456789101112/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; @SpringBootApplication: Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用； @SpringBootConfiguration: springboot的配置类 ​ 标注在某个类上,表示这是一个springboot的配置类 ​ @Configuration:配置类上来标注这个注解 ​ 配置类: 配置文件; 配置类也是容器中的一个组件; @Component @EnableAutoConfiguration: 开启自动配置功能 ​ 以前我们需要配置的东西,springboot帮我们自动配置; @EnableAutoConfiguration告诉springboot开启自动配置功能;这样自动配置才能生效; 点进去后的注解: 123@AutoConfigurationPackage@Import(EnableAutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; @AutoConfigurationPackage：自动配置包 ​ @Import(AutoConfigurationPackages.Registrar.class)： ​ Spring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class； ==将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；== ==Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；==以前我们需要自己配置的东西，自动配置类都帮我们； 四.配置文件1.配置文件springboot使用一个全局的配置文件,配置文件名是固定的; application.properties application.yml 配置文件的作用: 修改springboot自动配置的默认值;springboot在底层都给我们自动配置好; YAML (YAML Ain’t Markup Language) ​ YAML A Markup Language：是一个标记语言 ​ YAML isn’t Markup Language：不是一个标记语言； 标记语言： ​ 以前的配置文件；大多都使用的是 xxxx.xml文件； ​ YAML：以数据为中心，比json、xml等更适合做配置文件； ​ YAML：配置例子 12server: port: 8081 xml: 123&lt;server&gt; &lt;port&gt;8081&lt;/port&gt;&lt;/server&gt; 2.YAML语法:1.基本语法k:(空格)v：表示一对键值对（空格必须有）； 以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的 123server: port: 8081 path:/hello 属性和值也是大小写敏感； 2.值的写法字面量：普通的值（数字，字符串，布尔）k: v：字面直接来写； ​ 字符串默认不用加上单引号或者双引号； ​ “”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思 ​ name: “zhangsan \\n lisi”：输出；zhangsan 换行 lisi ​ ‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据 ​ name: ‘zhangsan \\n lisi’：输出；zhangsan \\n lisi 对象、Map（属性和值）（键值对）：k: v：在下一行来写对象的属性和值的关系；注意缩进 ​ 对象还是k: v的方式 123friends: lastName:张三 age: 20 行内写法: 1friends: &#123;lastName : 张三,age: 18&#125; 数组（List、Set）：用 - 值表示数组中的一个元素 1234pets: - cat - dog - pig 行内写法: 1pets: [cat,dog,pig] 3、配置文件值注入配置文件 12345678person: lastName: hello age: 18 boss: false birth: 1984/11/19 maps: &#123;k1: v1,k2: v2&#125; lists: [lisi,zhaoliu] dog : &#123;name: tom,age : 3&#125; javaBean： 1234567891011121314151617181920212223/** * 将配置文件中的配置的每一个属性的值,映射dao这个组件中 * @ConfigurationProperties : 告诉springboot将本类中的所有属性和配置文件中的相关的配置进行绑定; * prefix = \"person\": 配置文件中哪个下面的所有属性进行一一映射 * 只有这个组件是容器中的组件,才能使用容器提供的@ConfigurationProperties功能 */@Component@ConfigurationProperties(prefix = \"person\")public class Person &#123; private String lastName ; private Integer age ; private Boolean boss; private Date birth; private Map&lt;String ,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog;&#125; 导入配置文件处理器，以后编写配置就有提示了 123456&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 打印之后的person 1、properties配置文件在idea中默认utf-8可能会乱码调整 2、@Value获取值和@ConfigurationProperties获取值比较 @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个个指定 松散绑定（松散语法） 支持 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装 支持 不支持 配置文件yml还是properties他们都能获取到值； 如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value； 如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties； 3、配置文件注入值数据校验123456789101112131415161718192021222324@Component@ConfigurationProperties(prefix = \"person\")@Validatedpublic class Person &#123; /** * &lt;bean class=\"Person\"&gt; * &lt;property name=\"lastName\" value=\"字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;\"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 @Email //@Value(\"$&#123;person.last-name&#125;\") private String lastName; //@Value(\"#&#123;11*2&#125;\") private Integer age; //@Value(\"true\") private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 4、@PropertySource&amp;@ImportResource&amp;@Bean@PropertySource：加载指定的配置文件； 1234567891011121314151617181920212223242526272829/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = \"person\"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * @ConfigurationProperties(prefix = \"person\")默认从全局配置文件中获取值； * */@PropertySource(value = &#123;\"classpath:person.properties\"&#125;)@Component@ConfigurationProperties(prefix = \"person\")//@Validatedpublic class Person &#123; /** * &lt;bean class=\"Person\"&gt; * &lt;property name=\"lastName\" value=\"字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;\"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 // @Email //@Value(\"$&#123;person.last-name&#125;\") private String lastName; //@Value(\"#&#123;11*2&#125;\") private Integer age; //@Value(\"true\") private Boolean boss; @ImportResource：导入Spring的配置文件，让配置文件里面的内容生效； Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别； 想让Spring的配置文件生效，加载进来；@ImportResource标注在一个配置类上 12@ImportResource(locations = &#123;\"classpath:beans.xml\"&#125;)导入Spring的配置文件让其生效 不来编写Spring的配置文件 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"helloService\" class=\"com.atguigu.springboot.service.HelloService\"&gt;&lt;/bean&gt;&lt;/beans&gt; springboot推荐给容器中添加组件的方式;推荐使用全注解的方式 1.配置类@Configuration–&gt;spring配置文件 2.使用@Bean给容器中添加组件 12345678910111213141516171819202122/*** @Configuration: 指明当前类是一个配置类;就是用来取代之前的spring配置文件 (xxx.xml)**在配置文件中使用&lt;bean&gt;&lt;/bean&gt;标签来添加组件*/@Configurationpublic class SpringConfiguration &#123; //将方法的返回值添加dao容器中;容器中的这个组件默认的id就是方法名 @Bean public HelloService helloService()&#123; System.out.println(\"使用@Bean注解给容器中注入组件\"); return new HelloService(); &#125;&#125;class HelloService&#123;&#125; 5、配置文件占位符1、随机数12$&#123;random.value&#125;、$&#123;random.int&#125;、$&#123;random.long&#125;$&#123;random.int(10)&#125;、$&#123;random.int[1024,65536]&#125; 2、占位符获取之前配置的值，如果没有可以是用:指定默认值123456789person.last-name=张三$&#123;random.uuid&#125;person.age=$&#123;random.int&#125;person.birth=2017/12/15person.boss=falseperson.maps.k1=v1person.maps.k2=14person.lists=a,b,cperson.dog.name=$&#123;person.hello:hello&#125;_dogperson.dog.age=15 6、配置文件加载位置12345678910111213springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件–file:./config/–file:./–classpath:/config/–classpath:/优先级由高到底，高优先级的配置会覆盖低优先级的配置；SpringBoot会从这四个位置全部加载主配置文件；**互补配置**； 7.自动配置原理:SpringBoot启动的时候加载主配置类，开启了自动配置功能 ==@EnableAutoConfiguration==五.web开发1、简介使用SpringBoot； 1）、创建SpringBoot应用，选中我们需要的模块； 2）、SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来 3）、自己编写业务代码； 2.模板引擎JSP、Velocity、Freemarker、Thymeleaf SpringBoot推荐的Thymeleaf； 语法更简单，功能更强大； 1、引入thymeleaf；123456789101112 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; 2.1.6 &lt;/dependency&gt;切换thymeleaf版本&lt;properties&gt; &lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt; &lt;!-- 布局功能的支持程序 thymeleaf3主程序 layout2以上版本 --&gt; &lt;!-- thymeleaf2 layout1--&gt; &lt;thymeleaf-layout-dialect.version&gt;2.2.2&lt;/thymeleaf-layout-dialect.version&gt; &lt;/properties&gt; 2、Thymeleaf使用1234567891011@ConfigurationProperties(prefix = \"spring.thymeleaf\")public class ThymeleafProperties &#123; private static final Charset DEFAULT_ENCODING = Charset.forName(\"UTF-8\"); private static final MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf(\"text/html\"); public static final String DEFAULT_PREFIX = \"classpath:/templates/\"; public static final String DEFAULT_SUFFIX = \".html\"; // 只要我们把HTML页面放在classpath:/templates/，thymeleaf就能自动渲染； 使用： 1、导入thymeleaf的名称空间 1&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt; 2、使用thymeleaf语法； 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;成功！&lt;/h1&gt; &lt;!--th:text 将div里面的文本内容设置为 --&gt; &lt;div th:text=\"$&#123;hello&#125;\"&gt;这是显示欢迎信息&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3、语法规则1）、th:text；改变当前元素里面的文本内容； th：任意html属性；来替换原生属性的值 2）、表达式？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869Simple expressions:（表达式语法） Variable Expressions: $&#123;...&#125;：获取变量值；OGNL； 1）、获取对象的属性、调用方法 2）、使用内置的基本对象： #ctx : the context object. #vars: the context variables. #locale : the context locale. #request : (only in Web Contexts) the HttpServletRequest object. #response : (only in Web Contexts) the HttpServletResponse object. #session : (only in Web Contexts) the HttpSession object. #servletContext : (only in Web Contexts) the ServletContext object. $&#123;session.foo&#125; 3）、内置的一些工具对象：#execInfo : information about the template being processed.#messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #&#123;…&#125; syntax.#uris : methods for escaping parts of URLs/URIs#conversions : methods for executing the configured conversion service (if any).#dates : methods for java.util.Date objects: formatting, component extraction, etc.#calendars : analogous to #dates , but for java.util.Calendar objects.#numbers : methods for formatting numeric objects.#strings : methods for String objects: contains, startsWith, prepending/appending, etc.#objects : methods for objects in general.#bools : methods for boolean evaluation.#arrays : methods for arrays.#lists : methods for lists.#sets : methods for sets.#maps : methods for maps.#aggregates : methods for creating aggregates on arrays or collections.#ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration). Selection Variable Expressions: *&#123;...&#125;：选择表达式：和$&#123;&#125;在功能上是一样； 补充：配合 th:object=\"$&#123;session.user&#125;： &lt;div th:object=\"$&#123;session.user&#125;\"&gt; &lt;p&gt;Name: &lt;span th:text=\"*&#123;firstName&#125;\"&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text=\"*&#123;lastName&#125;\"&gt;Pepper&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text=\"*&#123;nationality&#125;\"&gt;Saturn&lt;/span&gt;.&lt;/p&gt; &lt;/div&gt; Message Expressions: #&#123;...&#125;：获取国际化内容 Link URL Expressions: @&#123;...&#125;：定义URL； @&#123;/order/process(execId=$&#123;execId&#125;,execType='FAST')&#125; Fragment Expressions: ~&#123;...&#125;：片段引用表达式 &lt;div th:insert=\"~&#123;commons :: main&#125;\"&gt;...&lt;/div&gt; Literals（字面量） Text literals: 'one text' , 'Another one!' ,… Number literals: 0 , 34 , 3.0 , 12.3 ,… Boolean literals: true , false Null literal: null Literal tokens: one , sometext , main ,…Text operations:（文本操作） String concatenation: + Literal substitutions: |The name is $&#123;name&#125;|Arithmetic operations:（数学运算） Binary operators: + , - , * , / , % Minus sign (unary operator): -Boolean operations:（布尔运算） Binary operators: and , or Boolean negation (unary operator): ! , notComparisons and equality:（比较运算） Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le ) Equality operators: == , != ( eq , ne )Conditional operators:条件运算（三元运算符） If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue)Special tokens: No-Operation: _ 3.SpringMVC自动配置1.Spring MVC auto-configurationSpring Boot 自动配置好了SpringMVC 以下是SpringBoot对SpringMVC的默认配置:==（WebMvcAutoConfiguration）== Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. 自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？）） ContentNegotiatingViewResolver：组合所有的视图解析器的； ==如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来；== Support for serving static resources, including support for WebJars (see below).静态资源文件夹路径,webjars Static index.html support. 静态首页访问 Custom Favicon support (see below). favicon.ico 自动注册了 of Converter, GenericConverter, Formatter beans. Converter：转换器； public String hello(User user)：类型转换使用Converter Formatter 格式化器； 2017.12.17===Date； 2.全面接管SpringMVC；SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己配置；所有的SpringMVC的自动配置都失效了 我们需要在配置类中添加@EnableWebMvc即可 4.拦截器进行登陆检查拦截器 12345678910111213141516171819202122232425262728293031323334/** * 登陆检查， *///注册为组件@Componentpublic class LoginHandlerInterceptor implements HandlerInterceptor &#123; //目标方法执行之前 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; Object user = request.getSession().getAttribute(\"loginUser\"); if(user == null)&#123; //未登陆，返回登陆页面 request.setAttribute(\"msg\",\"没有权限请先登陆\"); request.getRequestDispatcher(\"/index.html\").forward(request,response); return false; &#125;else&#123; //已登陆，放行请求 return true; &#125; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125;&#125; 注册拦截器 1.首先将 LoginInterceptor 注入到 WebConfigurer 中。12@Autowiredprivate LoginInterceptor loginInterceptor; 2.然后在 WebConfigurer 中的 addInterceptors 中添加拦截器，使其生效。@Override public void addInterceptors(InterceptorRegistry registry) { // addPathPatterns(&quot;/**&quot;) 表示拦截所有的请求， // excludePathPatterns(&quot;/login&quot;, &quot;/register&quot;) 表示除了登陆与注册之外，因为登陆注册不需要登陆也可以访问 registry.addInterceptor(loginInterceptor).addPathPatterns(&quot;/**&quot;).excludePathPatterns(&quot;/login&quot;, &quot;/register&quot;); super.addInterceptors(registry); //较新Spring Boot的版本中这里可以直接去掉，否则会报错 }3.addPathPatterns 用来设置拦截路径，excludePathPatterns 用来设置白名单，也是不需要触发这个拦截器的路径。 完整代码： 1234567891011121314151617181920@Configurationpublic class WebConfigurer implements WebMvcConfigurer &#123; @Autowired private LoginInterceptor loginInterceptor; // 这个方法是用来配置静态资源的，比如html，js，css，等等 @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; &#125; // 这个方法用来注册拦截器，我们自己写好的拦截器需要通过这里添加注册才能生效 @Override public void addInterceptors(InterceptorRegistry registry) &#123; // addPathPatterns(\"/**\") 表示拦截所有的请求， // excludePathPatterns(\"/login\", \"/register\") 表示除了登陆与注册之外，因为登陆注册不需要登陆也可以访问 registry.addInterceptor(loginInterceptor).addPathPatterns(\"/**\").excludePathPatterns(\"/login\", \"/register\"); &#125;&#125; 六.SpringBoot与数据访问1.JDBC123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 数据源的配置文件: 123456spring: datasource: username: root password: 123456 url: jdbc:mysql://192.168.15.22:3306/jdbc driver-class-name: com.mysql.jdbc.Driver 2.整合MyBatis12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; 步骤： ​ 1）、配置数据源相关属性（见上一节Druid） ​ 2）、给数据库建表 ​ 3）、创建JavaBean 1）、注解版( 接口类UserMapper.java和配置文件UserMapper.xml,最后在入口类中使用MapperScan批量扫描所有的Mapper接口；@MapperScan(value = “com.atguigu.springboot.mapper”) ) 接口类UserMapper.java1234567891011121314151617//指定这是一个操作数据库的mapper@Mapperpublic interface DepartmentMapper &#123; @Select(\"select * from department where id=#&#123;id&#125;\") public Department getDeptById(Integer id); @Delete(\"delete from department where id=#&#123;id&#125;\") public int deleteDeptById(Integer id); @Options(useGeneratedKeys = true,keyProperty = \"id\") @Insert(\"insert into department(departmentName) values(#&#123;departmentName&#125;)\") public int insertDept(Department department); @Update(\"update department set departmentName=#&#123;departmentName&#125; where id=#&#123;id&#125;\") public int updateDept(Department department);&#125; 配置文件UserMapper.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.jf.exam.mapper.AdminStudentMapper\"&gt; &lt;resultMap id=\"studentMapper\" type=\"studentDO\"&gt; &lt;result property=\"id\" column=\"id\"/&gt; &lt;result property=\"sno\" column=\"sno\"/&gt; &lt;result property=\"name\" column=\"name\"/&gt; &lt;result property=\"password\" column=\"password\"/&gt; &lt;result property=\"fkClass\" column=\"fk_class\"/&gt; &lt;result property=\"modified\" column=\"modified\"/&gt; &lt;result property=\"delFlag\" column=\"del_flag\"/&gt; &lt;/resultMap&gt; &lt;sql id=\"_table\"&gt; student &lt;/sql&gt; &lt;sql id=\"_fields\"&gt; id,sno,`name`,`password`,fk_class,modified,del_flag &lt;/sql&gt; &lt;sql id=\"_condition\"&gt; &lt;trim prefix=\"WHERE\" prefixOverrides=\"AND|OR\"&gt; &lt;if test=\"id!=null and ''!=id\"&gt; AND id = #&#123;id&#125; &lt;/if&gt; &lt;if test=\"sno!=null and ''!=sno\"&gt; AND sno = #&#123;sno&#125; &lt;/if&gt; &lt;if test=\"name!=null and ''!=name\"&gt; AND `name` = #&#123;name&#125; &lt;/if&gt; &lt;if test=\"password!=null and ''!=password\"&gt; AND `password` = #&#123;password&#125; &lt;/if&gt; &lt;if test=\"fkClass!=null\"&gt; AND fk_class = #&#123;fkClass&#125; &lt;/if&gt; &lt;if test=\"modified!=null\"&gt; AND modified = #&#123;modified&#125; &lt;/if&gt; &lt;if test=\"delFlag!=null and ''!=delFlag\"&gt; AND del_flag = #&#123;delFlag&#125; &lt;/if&gt; &lt;/trim&gt; &lt;/sql&gt; &lt;sql id=\"_primaryKey_condition\"&gt; WHERE id = #&#123;id&#125; &lt;/sql&gt; &lt;sql id=\"_order\"&gt; &lt;if test=\"sortByParams!= null and sortByParams.size()&gt;0\" &gt; ORDER BY &lt;foreach collection=\"sortByParams.keys\" index=\"index\" item=\"sortByParamKey\" separator=\",\"&gt; &lt;![CDATA[$&#123;sortByParamKey&#125; $&#123;sortByParams[sortByParamKey]&#125;]]&gt; &lt;/foreach&gt; &lt;/if&gt; &lt;/sql&gt; &lt;insert id=\"add\" parameterType=\"studentVO\" keyProperty=\"id\"&gt; INSERT INTO &lt;include refid=\"_table\"/&gt; &lt;trim prefix=\"(\" suffix=\")\" suffixOverrides=\",\"&gt; &lt;if test=\"id!=null and ''!=id\"&gt; id, &lt;/if&gt; &lt;if test=\"sno!=null and ''!=sno\"&gt; sno, &lt;/if&gt; &lt;if test=\"name!=null and ''!=name\"&gt; `name`, &lt;/if&gt; &lt;if test=\"password!=null and ''!=password\"&gt; `password`, &lt;/if&gt; &lt;if test=\"fkClass!=null\"&gt; fk_class, &lt;/if&gt; &lt;if test=\"modified!=null\"&gt; modified, &lt;/if&gt; &lt;if test=\"delFlag!=null and ''!=delFlag\"&gt; del_flag, &lt;/if&gt; &lt;/trim&gt; &lt;trim prefix=\"values (\" suffix=\")\" suffixOverrides=\",\"&gt; &lt;if test=\"id!=null and ''!=id\"&gt; #&#123;id&#125;, &lt;/if&gt; &lt;if test=\"sno!=null and ''!=sno\"&gt; #&#123;sno&#125;, &lt;/if&gt; &lt;if test=\"name!=null and ''!=name\"&gt; #&#123;name&#125;, &lt;/if&gt; &lt;if test=\"password!=null and ''!=password\"&gt; #&#123;password&#125;, &lt;/if&gt; &lt;if test=\"fkClass!=null\"&gt; #&#123;fkClass&#125;, &lt;/if&gt; &lt;if test=\"modified!=null\"&gt; #&#123;modified&#125;, &lt;/if&gt; &lt;if test=\"delFlag!=null and ''!=delFlag\"&gt; #&#123;delFlag&#125;, &lt;/if&gt; &lt;/trim&gt; &lt;/insert&gt; &lt;update id=\"updateById\" parameterType=\"studentVO\"&gt; UPDATE &lt;include refid=\"_table\"/&gt; &lt;set&gt; &lt;if test=\"sno!=null and ''!=sno\"&gt; sno = #&#123;sno&#125;, &lt;/if&gt; &lt;if test=\"name!=null and ''!=name\"&gt; `name` = #&#123;name&#125;, &lt;/if&gt; &lt;if test=\"password!=null and ''!=password\"&gt; `password` = #&#123;password&#125;, &lt;/if&gt; &lt;if test=\"fkClass!=null\"&gt; fk_class = #&#123;fkClass&#125;, &lt;/if&gt; &lt;if test=\"modified!=null\"&gt; modified = #&#123;modified&#125;, &lt;/if&gt; &lt;if test=\"delFlag!=null and ''!=delFlag\"&gt; del_flag = #&#123;delFlag&#125;, &lt;/if&gt; &lt;/set&gt; &lt;include refid=\"_primaryKey_condition\"/&gt; &lt;/update&gt; &lt;select id=\"findById\" resultMap=\"studentMapper\" parameterType=\"String\"&gt; SELECT &lt;include refid=\"_fields\"/&gt; FROM &lt;include refid=\"_table\"/&gt; &lt;include refid=\"_primaryKey_condition\"/&gt; &lt;/select&gt; &lt;select id=\"list\" resultMap=\"studentMapper\" parameterType=\"studentVO\"&gt; SELECT &lt;include refid=\"_fields\"/&gt; FROM &lt;include refid=\"_table\"/&gt; &lt;include refid=\"_condition\"/&gt; &lt;include refid=\"_order\"/&gt; &lt;/select&gt; &lt;select id=\"listPage\" resultMap=\"studentMapper\" parameterType=\"studentVO\"&gt; SELECT &lt;include refid=\"_fields\"/&gt; FROM &lt;include refid=\"_table\"/&gt; &lt;include refid=\"_condition\"/&gt; &lt;include refid=\"_order\"/&gt; &lt;if test=\"startRecord != null and pageSize != null and pageSize &gt;0\"&gt; limit #&#123;startRecord&#125;,#&#123;pageSize&#125; &lt;/if&gt; &lt;if test=\"!(startRecord != null and pageSize != null and pageSize &gt;0)\"&gt; limit 0,15 &lt;/if&gt; &lt;/select&gt; &lt;select id=\"count\" resultType=\"java.lang.Integer\" parameterType=\"studentVO\"&gt; SELECT COUNT(*) FROM &lt;include refid=\"_table\"/&gt; &lt;include refid=\"_condition\"/&gt; &lt;/select&gt; &lt;delete id=\"deleteById\" parameterType=\"String\"&gt; DELETE FROM &lt;include refid=\"_table\"/&gt; &lt;include refid=\"_primaryKey_condition\"/&gt; &lt;/delete&gt; &lt;select id=\"listStudentAssociation\" resultMap=\"listStudentAssociationResultMap\" parameterType=\"com.jf.exam.pojo.vo.StudentVO\"&gt; SELECT s.id sid, s.sno sno, s.`name` sname, c.id cid, c.cno cno, g.id gid, g.`name` gname, m.id mid, m.`name` mname FROM student s LEFT JOIN class c ON s.fk_class = c.id LEFT JOIN grade g ON g.id = c.fk_grade LEFT JOIN major m ON m.id = c.fk_major &lt;where&gt; &lt;if test=\"name!=null and ''!=name\"&gt; s.`name`= #&#123;name&#125; &lt;/if&gt; &lt;/where&gt; &lt;if test=\"startRecord != null and pageSize != null and pageSize &gt;0\"&gt; limit #&#123;startRecord&#125;,#&#123;pageSize&#125; &lt;/if&gt; &lt;if test=\"!(startRecord != null and pageSize != null and pageSize &gt;0)\"&gt; limit 0,15 &lt;/if&gt; &lt;/select&gt; &lt;resultMap id=\"listStudentAssociationResultMap\" type=\"com.jf.exam.pojo.vo.StudentListVO\"&gt; &lt;id column=\"sid\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"sno\" property=\"sno\"&gt;&lt;/result&gt; &lt;result column=\"sname\" property=\"name\"&gt;&lt;/result&gt; &lt;association property=\"gradeDO\" javaType=\"com.jf.exam.pojo.data.GradeDO\"&gt; &lt;id column=\"gid\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"gname\" property=\"name\"&gt;&lt;/result&gt; &lt;/association&gt; &lt;association property=\"classDO\" javaType=\"com.jf.exam.pojo.data.ClassDO\"&gt; &lt;id column=\"cid\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"cno\" property=\"cno\"&gt;&lt;/result&gt; &lt;/association&gt; &lt;association property=\"majorDO\" javaType=\"com.jf.exam.pojo.data.MajorDO\"&gt; &lt;id column=\"mid\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"mname\" property=\"name\"&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt;&lt;/mapper&gt; 扫描所有的Mapper接口123456789使用MapperScan批量扫描所有的Mapper接口；@MapperScan(value = \"com.atguigu.springboot.mapper\")@SpringBootApplicationpublic class SpringBoot06DataMybatisApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot06DataMybatisApplication.class, args); &#125;&#125;","categories":[],"tags":[]},{"title":"hexo博客的搭建","slug":"hexo博客的搭建-必看","date":"2019-11-26T04:59:05.000Z","updated":"2019-11-26T06:37:33.100Z","comments":true,"path":"2019/11/26/hexo博客的搭建-必看/","link":"","permalink":"http://yoursite.com/2019/11/26/hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA-%E5%BF%85%E7%9C%8B/","excerpt":"","text":"Hexo 博客的搭建前言,首先要搭建hexo博客,需要git(github账号),node.js==1.git== git的安装 : 按住Ctrl点我下载 安装步骤: 下载msi的文件后,双击安装,一路next,安装完成后,win+ R 输入cmd确定,在命令行里输入 命令:git --version,查看版本如下 ==2.node.js== 点我下载Node.js :windows安装包 安装步骤: 下载msi的文件后,双击安装,一路next,安装完成后,win+ R 输入cmd确定,在命令行里输入 命令:node -v,查看版本如下 ==3.安装hexo== 首先创建一个文件夹,用来存放博客中的东西 在新建的文件夹下鼠标右键 选择git bash here打开git命令行,输入 npm install hexo -g进行全局安装hexo,安装完成之后,查看版本号确认安装hexo -v 然后进行hexo 的初始化,输入hexo init,看到如下的列表 node_modules：是依赖包 public：存放的是生成的页面 scaffolds：命令生成文章等的模板 source：用命令创建的各种文章 themes：主题 _config.yml：整个博客的配置 db.json：source解析所得到的 package.json：项目所需模块项目的配置信息 ==4.Github仓库== 创建一个repo，名称为yourname.github.io,输入的一个标点都不能错, 其中yourname是你的github账号的名称，按照这个规则创建才有用，否则永远的404页面 搭建好github环境之后,开始进行hexo博客的搭建 4.1._config.yml的修改用编辑器打开你的blog项目，修改_config.yml文件的一些配置(冒号之后都是有一个半角空格的(yaml语法格式))： 1234deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 4.2安装hexo-deployer-git插件 1npm install hexo-deployer-git --save 4.3.生成hexo静态页面 回到gitbash中，进入你的博客目录，分别执行以下命令 123hexo cleanhexo generatehexo server 5.完成效果图","categories":[],"tags":[{"name":"hexo博客","slug":"hexo博客","permalink":"http://yoursite.com/tags/hexo%E5%8D%9A%E5%AE%A2/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-11-25T14:25:04.405Z","updated":"2019-11-25T14:25:04.406Z","comments":true,"path":"2019/11/25/hello-world/","link":"","permalink":"http://yoursite.com/2019/11/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}